<!DOCTYPE html>
<html lang="es" class="h-full scroll-smooth">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GuestsValencia Â· Alojamientos Inteligentes en Valencia con IA</title>
  <!-- ... [SAME HEAD CONTENT] ... -->
  <meta name="description"
    content="Descubre alojamientos premium en Valencia con llegada autÃ³noma, gestiÃ³n inteligente y soporte 24/7 por nuestra IA Sandra. Tu estancia perfecta empieza aquÃ­.">
  <meta name="keywords"
    content="alojamientos valencia, apartamentos turÃ­sticos, alquiler vacacional valencia, sandra ia, galaxy pro, llegada autÃ³noma, smart lock">
  <link rel="canonical" href="https://guestsvalencia.es/">

  <!-- PWA -->
  <meta name="theme-color" content="#0F172A">
  <link rel="manifest" href="/manifest.webmanifest?v=2">
	  <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
  <link rel="apple-touch-icon" href="/assets/icons/apple-touch-icon.png?v=2">
	  <meta name="apple-mobile-web-app-capable" content="yes">
	  <meta name="mobile-web-app-capable" content="yes">
	  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="GuestsValencia Â· Alojamientos Inteligentes con IA">
  <meta property="og:description"
    content="Experimenta el futuro del alojamiento en Valencia. Llegada autÃ³noma, confort y asistencia IA 24/7.">
  <meta property="og:image" content="https://guestsvalencia.es/assets/media/og-image.jpg">
  <meta property="og:url" content="https://guestsvalencia.es/">

  <!-- Schema.org -->
  <script type="application/ld+json">
  {"@context":"https://schema.org","@graph":[{"@type":"Organization","name":"GuestsValencia","url":"https://guestsvalencia.es/","logo":"https://guestsvalencia.es/assets/media/logo-guestsvalencia-dark.svg","contactPoint":{"@type":"ContactPoint","telephone":"+34-624-020-085","contactType":"customer service"}},{"@type":"LodgingBusiness","name":"GuestsValencia","url":"https://guestsvalencia.es/","description":"Alojamientos premium con llegada autÃ³noma y asistencia IA en Valencia.","address":{"@type":"PostalAddress","addressLocality":"Valencia","addressCountry":"ES"},"telephone":"+34-624-020-085","priceRange":"â‚¬â‚¬-â‚¬â‚¬â‚¬"}]}
  </script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap"
    rel="stylesheet">

	  <!-- Tailwind -->
	  <link rel="stylesheet" href="/assets/tailwind.css">

  <style>
    :root {
      --primary: #2563EB;
      --accent: #3B82F6;
      --accent-light: #60A5FA;
      --accent-lighter: #93C5FD;
      --accent-dark: #1E40AF;
      --glass-bg: rgba(255, 255, 255, 0.98);
      --glass-dark-bg: rgba(37, 99, 235, 0.85);
      --text-primary: #0F172A;
      --text-secondary: #334155;
      --bg-light: #FFFFFF;
      --bg-section: #F8FAFC;
      --bg-accent: #EFF6FF
    }

    body {
      font-family: 'Outfit', system-ui, sans-serif;
      background: var(--bg-light);
      color: var(--text-primary);
      overflow-x: hidden;
      margin: 0;
      padding: 0
    }

    html {
      margin: 0;
      padding: 0
    }

    h1,
    h2,
    h3 {
      font-family: 'Playfair Display', Georgia, serif
    }

    .glass {
      background: var(--glass-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.4);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1)
    }

    .glass-dark {
      background: var(--glass-dark-bg);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: white;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15)
    }

    .hero-section {
      position: relative;
      min-height: 100vh;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      overflow: hidden;
      padding-bottom: 10vh
    }

    .hero-video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: -2
    }

    .hero-background-image {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-size: cover;
      background-position: center 35%;
      z-index: -3;
      transition: transform 0.3s ease
    }

    /* Movimiento sutil del Hero durante llamada (sin video) */
    .hero-motion {
      animation: hero-motion 10s ease-in-out infinite;
      will-change: transform
    }

    @keyframes hero-motion {

      0%,
      100% {
        transform: scale(1) translate3d(0, 0, 0)
      }

      50% {
        transform: scale(1.015) translate3d(0, -0.6%, 0)
      }
    }

    /* SubtÃ­tulos siempre visibles y con saltos de lÃ­nea cuando se muestran */
    #sandra-subtitles span {
      white-space: pre-line;
      display: inline-block;
      line-height: 1.5
    }

    .property-card {
      transition: transform 0.3s, box-shadow 0.3s
    }

    .property-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1)
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent), var(--primary));
      color: white;
      box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3)
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
      background: linear-gradient(135deg, var(--accent-light), var(--accent))
    }

    .page {
      display: none
    }

    .page.active {
      display: block
    }

    .lightbox {
      display: none;
      position: fixed;
      z-index: 1000;
      inset: 0;
      background: rgba(11, 16, 32, 0.95);
      backdrop-filter: blur(8px);
      justify-content: center;
      align-items: center
    }

    .lightbox.show {
      display: flex
    }

    #sandra-widget-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 9999
    }

    #search-container.active {
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5), 0 0 20px rgba(59, 130, 246, 0.3), 0 0 40px rgba(59, 130, 246, 0.2)
    }

    #search-container.active .glass {
      border-color: rgba(59, 130, 246, 0.5)
    }

    .ai-search-active {
      animation: pulse-glow 2s ease-in-out infinite
    }

    @keyframes pulse-glow {

      0%,
      100% {
        box-shadow: 0 0 0 0 rgba(147, 51, 234, 0.7), 0 0 20px rgba(147, 51, 234, 0.5)
      }

      50% {
        box-shadow: 0 0 0 10px rgba(147, 51, 234, 0), 0 0 30px rgba(147, 51, 234, 0.8)
      }
    }

    @keyframes fade-in {
      from {
        opacity: 0;
        transform: translateY(10px)
      }

      to {
        opacity: 1;
        transform: translateY(0)
      }
    }

    @keyframes pulse-slow {

      0%,
      100% {
        opacity: 1
      }

      50% {
        opacity: 0.7
      }
    }

    .animate-fade-in {
      animation: fade-in 1s ease-in-out
    }

    .animate-pulse-slow {
      animation: pulse-slow 2s ease-in-out infinite
    }

    /* ðŸš€ FASE 2: Estilos para efectos de navegaciÃ³n y UI */
    .nav-highlight {
      background: linear-gradient(135deg, rgba(100, 200, 255, 0.1), rgba(150, 100, 255, 0.1)) !important;
      transition: all 0.5s ease-in-out;
      border-left: 4px solid #6eb3ff;
      padding-left: 12px !important;
    }

    .highlighted {
      background: rgba(255, 215, 0, 0.2) !important;
      border: 2px solid #ffd700 !important;
      border-radius: 4px;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
      animation: pulse-highlight 0.6s ease-in-out;
    }

    @keyframes pulse-highlight {
      0% { box-shadow: 0 0 5px rgba(255, 215, 0, 0.4); }
      50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
      100% { box-shadow: 0 0 5px rgba(255, 215, 0, 0.4); }
    }

    .modal-open {
      animation: modal-fade-in 0.3s ease-in-out;
    }

    @keyframes modal-fade-in {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }

    html { scroll-behavior: smooth; }

    .section-active {
      border-top: 3px solid #6eb3ff;
      padding-top: 15px;
    }
  </style>
</head>

<body class="font-sans text-slate-900 bg-white min-h-full flex flex-col">

  <!-- NAVBAR -->
  <nav id="main-nav"
    class="fixed top-0 left-0 right-0 w-full z-50 h-24 flex items-center transition-all duration-300 bg-black/20 backdrop-blur-md border-b border-white/10 shadow-sm">
    <div class="w-full max-w-7xl mx-auto px-6 flex justify-between items-center">
      <a href="#home"
        class="nav-link text-3xl font-bold text-white flex items-center gap-1 font-serif tracking-tight drop-shadow-md">
        <span class="text-blue-400">Guests</span>Valencia
      </a>

      <div class="hidden lg:flex gap-8 text-base font-medium text-white/90">
        <a href="#home" class="nav-link hover:text-blue-300 transition-colors relative group shadow-sm">
          Inicio
          <span class="absolute -bottom-1 left-0 w-0 h-0.5 bg-blue-400 transition-all group-hover:w-full"></span>
        </a>
        <a href="#alojamientos" class="nav-link hover:text-blue-300 transition-colors relative group shadow-sm">
          Alojamientos
          <span class="absolute -bottom-1 left-0 w-0 h-0.5 bg-blue-400 transition-all group-hover:w-full"></span>
        </a>
        <a href="#servicios" class="nav-link hover:text-blue-300 transition-colors relative group shadow-sm">
          Servicios
          <span class="absolute -bottom-1 left-0 w-0 h-0.5 bg-blue-400 transition-all group-hover:w-full"></span>
        </a>
        <a href="#owners" class="nav-link hover:text-blue-300 transition-colors relative group shadow-sm">
          Propietarios
          <span class="absolute -bottom-1 left-0 w-0 h-0.5 bg-blue-400 transition-all group-hover:w-full"></span>
        </a>
        <a href="#quienes-somos" class="nav-link hover:text-blue-300 transition-colors relative group shadow-sm">
          QuiÃ©nes Somos
          <span class="absolute -bottom-1 left-0 w-0 h-0.5 bg-blue-400 transition-all group-hover:w-full"></span>
        </a>
        <a href="#contacto" class="nav-link hover:text-blue-300 transition-colors relative group shadow-sm">
          Contacto
          <span class="absolute -bottom-1 left-0 w-0 h-0.5 bg-blue-400 transition-all group-hover:w-full"></span>
        </a>
        <a href="https://app.guestsvalencia.es"
          class="nav-link hover:text-blue-300 transition-colors relative group shadow-sm">
          ðŸ“± App
          <span class="absolute -bottom-1 left-0 w-0 h-0.5 bg-blue-400 transition-all group-hover:w-full"></span>
        </a>
      </div>

      <div class="flex gap-4 items-center">
        <a href="#login"
          class="nav-link hidden sm:block text-white/90 hover:text-white text-base font-medium">Acceder</a>
        <a href="#register"
          class="nav-link bg-white/10 hover:bg-white/20 border border-white/20 text-white px-6 py-3 rounded-full text-base font-bold backdrop-blur-sm transition-all transform hover:scale-105">
          Registrarse
        </a>
      </div>
    </div>
  </nav>

  <main class="flex-1">
    <!-- Fallback para el widget de Sandra: se reemplaza dinÃ¡micamente al inicializar -->
    <div id="sandra-widget-root" class="hidden" aria-live="polite"></div>

    <!-- HOME -->
    <section id="home-page" class="page active">
      <header class="hero-section">
        <video id="hero-video" class="hero-video" autoplay muted loop playsinline style="display:none;"
          poster="assets/images/sandra-avatar.png">
          <source src="" type="video/mp4">
        </video>
        <div id="hero-background-image" class="hero-background-image"
          style="background-image: url('https://images.unsplash.com/photo-1600607687644-c7171b42498b?auto=format&fit=crop&w=1920&q=95'); filter: brightness(1.05) contrast(1.1); background-size: cover; background-position: center 35%;">
        </div>
        <!-- Selector de carga para Hero -->
        <div class="absolute top-4 right-4 z-50">
          <label for="hero-media-upload"
            class="cursor-pointer bg-white/90 hover:bg-white backdrop-blur-sm px-4 py-2 rounded-lg shadow-lg text-sm font-semibold text-blue-600 flex items-center gap-2 transition-all hover:shadow-xl">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
            Cambiar Hero
          </label>
          <input type="file" id="hero-media-upload" accept="image/*,video/*" class="hidden">
        </div>
        <div class="relative z-10 text-center px-6 max-w-4xl mx-auto" style="margin-top: 45vh;">
          <p class="text-lg md:text-xl text-white mb-8 max-w-2xl mx-auto font-semibold drop-shadow-2xl"
            style="text-shadow: 0 2px 12px rgba(0,0,0,0.4), 0 0 20px rgba(0,0,0,0.2);">Apartamentos de diseÃ±o con
            llegada autÃ³noma y asistencia 24 horas impulsadas por Sandra IA</p>
          <div id="search-container"
            class="glass p-2 rounded-2xl max-w-4xl mx-auto shadow-2xl transition-all duration-300">
            <form id="search-form" class="flex flex-col md:flex-row gap-2 items-center">
              <div class="flex-1 w-full md:w-auto flex gap-2">
                <input type="text" id="search-destination" placeholder="Â¿A dÃ³nde viajas? Ej: Ruzafa..."
                  class="flex-1 pl-4 py-4 rounded-xl bg-white/90 text-slate-800 placeholder-slate-500 font-medium outline-none focus:ring-2 focus:ring-blue-500 focus:bg-white transition-all">
                <div class="relative">
                  <input type="number" id="search-guests" value="2" min="1" aria-label="NÃºmero de personas"
                    class="w-32 px-4 py-4 rounded-xl bg-white/90 text-slate-800 font-medium outline-none focus:ring-2 focus:ring-blue-500 focus:bg-white transition-all pr-16">
                  <span
                    class="absolute right-4 top-1/2 -translate-y-1/2 text-slate-500 text-sm pointer-events-none">Personas</span>
                </div>
                <div class="relative">
                  <input type="number" id="search-nights" value="1" min="1" aria-label="NÃºmero de noches"
                    class="w-32 px-4 py-4 rounded-xl bg-white/90 text-slate-800 font-medium outline-none focus:ring-2 focus:ring-blue-500 focus:bg-white transition-all pr-16">
                  <span
                    class="absolute right-4 top-1/2 -translate-y-1/2 text-slate-500 text-sm pointer-events-none">Noches</span>
                </div>
              </div>
              <div class="flex gap-2 w-full md:w-auto">
                <button type="button" id="btn-search-normal"
                  class="px-6 py-4 rounded-xl bg-blue-600 text-white font-bold hover:bg-blue-700 shadow-lg transition-all flex items-center gap-2">
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                  </svg>
                  Buscar
                </button>
                <button type="button" id="btn-search-ai"
                  class="px-6 py-4 rounded-xl bg-gradient-to-r from-purple-600 to-blue-600 text-white font-bold hover:from-purple-700 hover:to-blue-700 shadow-lg transition-all flex items-center gap-2 relative overflow-hidden group">
                  <span
                    class="absolute inset-0 bg-gradient-to-r from-purple-400 to-blue-400 opacity-0 group-hover:opacity-100 transition-opacity duration-300"></span>
                  <svg class="w-5 h-5 relative z-10" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                      d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                  </svg>
                  <span class="relative z-10">Buscar con IA</span>
                  <span id="ai-search-pulse" class="absolute inset-0 rounded-xl opacity-0 group-hover:opacity-100">
                    <span
                      class="absolute inset-0 rounded-xl bg-gradient-to-r from-purple-400/50 to-blue-400/50 animate-ping"></span>
                  </span>
                </button>
              </div>
            </form>
          </div>
        </div>
      </header>

      <!-- VALORES PRINCIPALES -->
      <section class="py-24 px-6 bg-white">
        <div class="max-w-7xl mx-auto">
          <div class="text-center mb-16">
            <span class="text-blue-600 font-bold tracking-wider uppercase text-sm mb-2 block">Nuestros Pilares</span>
            <h2 class="text-3xl md:text-4xl font-bold text-slate-900 mb-4">TecnologÃ­a, Transparencia y Experiencia
              Personalizada</h2>
            <p class="text-slate-600 max-w-3xl mx-auto">Descubre los factores clave de nuestra gestiÃ³n de propiedades
              para particulares y empresas en Valencia.</p>
          </div>
          <div class="grid md:grid-cols-3 gap-8">
            <div
              class="bg-gradient-to-br from-blue-50/60 to-white p-8 rounded-2xl border border-blue-100/60 hover:shadow-xl transition-all">
              <div class="w-16 h-16 bg-blue-600 rounded-2xl flex items-center justify-center mb-6">
                <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
                </svg>
              </div>
              <h3 class="text-2xl font-bold text-slate-900 mb-4">TecnologÃ­a Propia con Sandra IA</h3>
              <p class="text-slate-600 mb-4">Ofrecemos seguimiento en tiempo real de cada proceso con acceso inmediato a
                toda la informaciÃ³n de tus propiedades.</p>
              <ul class="space-y-2 text-sm text-slate-600">
                <li class="flex items-start gap-2"><span class="text-blue-600 mt-1">âœ“</span> ActualizaciÃ³n de reservas y
                  tareas en tiempo real</li>
                <li class="flex items-start gap-2"><span class="text-blue-600 mt-1">âœ“</span> Toda la informaciÃ³n en una
                  sola aplicaciÃ³n</li>
                <li class="flex items-start gap-2"><span class="text-blue-600 mt-1">âœ“</span> Asistente IA 24/7 con
                  videollamada conversacional</li>
                <li class="flex items-start gap-2"><span class="text-blue-600 mt-1">âœ“</span> Notificaciones automÃ¡ticas
                  de intervenciones</li>
              </ul>
            </div>
            <div
              class="bg-gradient-to-br from-blue-50/60 to-white p-8 rounded-2xl border border-blue-100/60 hover:shadow-xl transition-all">
              <div class="w-16 h-16 bg-blue-500 rounded-2xl flex items-center justify-center mb-6">
                <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
                </svg>
              </div>
              <h3 class="text-2xl font-bold text-slate-900 mb-4">Transparencia Total</h3>
              <p class="text-slate-600 mb-4">Actuamos como Responsables del Tratamiento, garantizando uso lÃ­cito, leal y
                transparente de tus datos.</p>
              <ul class="space-y-2 text-sm text-slate-600">
                <li class="flex items-start gap-2"><span class="text-blue-600 mt-1">âœ“</span> Seguimiento detallado de
                  cada proceso</li>
                <li class="flex items-start gap-2"><span class="text-blue-600 mt-1">âœ“</span> InformaciÃ³n completa y
                  accesible</li>
                <li class="flex items-start gap-2"><span class="text-blue-600 mt-1">âœ“</span> ComunicaciÃ³n clara y
                  directa</li>
                <li class="flex items-start gap-2"><span class="text-blue-600 mt-1">âœ“</span> Cumplimiento GDPR y
                  normativas</li>
              </ul>
            </div>
            <div
              class="bg-gradient-to-br from-blue-50/60 to-white p-8 rounded-2xl border border-blue-100/60 hover:shadow-xl transition-all">
              <div class="w-16 h-16 bg-blue-400 rounded-2xl flex items-center justify-center mb-6">
                <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                </svg>
              </div>
              <h3 class="text-2xl font-bold text-slate-900 mb-4">Experiencia Personalizada</h3>
              <p class="text-slate-600 mb-4">Aseguramos una gestiÃ³n eficiente que optimiza la operativa y la experiencia
                tanto para propietarios como huÃ©spedes.</p>
              <ul class="space-y-2 text-sm text-slate-600">
                <li class="flex items-start gap-2"><span class="text-blue-600 mt-1">âœ“</span> Protocolos adaptados a cada
                  propiedad</li>
                <li class="flex items-start gap-2"><span class="text-blue-600 mt-1">âœ“</span> Disponibilidad los 365
                  dÃ­as, festivos incluidos</li>
                <li class="flex items-start gap-2"><span class="text-blue-600 mt-1">âœ“</span> Check-in flexible y
                  autÃ³nomo</li>
                <li class="flex items-start gap-2"><span class="text-blue-600 mt-1">âœ“</span> AtenciÃ³n personalizada con
                  Sandra IA</li>
              </ul>
            </div>
          </div>
        </div>
      </section>

      <!-- ESTADÃSTICAS -->
      <section class="py-16 px-6 bg-blue-50/30">
        <div class="max-w-7xl mx-auto">
          <h2 class="text-2xl md:text-3xl font-bold text-slate-900 mb-8 text-center">Nuestros datos nos avalan</h2>
          <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
            <div class="text-center">
              <div class="text-5xl md:text-6xl font-bold text-blue-600 mb-2">+5</div>
              <div class="text-lg text-slate-600">AÃ±os de experiencia</div>
            </div>
            <div class="text-center">
              <div class="text-5xl md:text-6xl font-bold text-blue-600 mb-2">+50</div>
              <div class="text-lg text-slate-600">Propiedades gestionadas</div>
            </div>
            <div class="text-center">
              <div class="text-5xl md:text-6xl font-bold text-blue-600 mb-2">98%</div>
              <div class="text-lg text-slate-600">SatisfacciÃ³n de huÃ©spedes</div>
            </div>
          </div>
        </div>
      </section>

      <!-- FEATURED LISTINGS -->
      <section class="py-24 px-6 max-w-7xl mx-auto">
        <h2 class="text-3xl md:text-4xl font-bold text-slate-900 mb-4 text-center">Alojamientos Destacados</h2>
        <p class="text-slate-600 text-center mb-12 max-w-xl mx-auto">Una selecciÃ³n curada de nuestros mejores
          alojamientos.</p>
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8" id="featured-grid"></div>
        <div class="mt-10 text-center">
          <a href="#alojamientos" class="nav-link inline-block btn-primary px-8 py-3 rounded-xl font-bold">Ver todos los
            alojamientos</a>
        </div>
      </section>

      <!-- SANDRA IA SECTION -->
      <section class="bg-white py-16 md:py-24 border-t border-slate-200">
        <div class="max-w-7xl mx-auto px-6 grid md:grid-cols-2 gap-8 md:gap-12 items-end">
          <div class="order-2 md:order-1">
            <span class="text-blue-600 font-bold tracking-wider uppercase text-sm mb-2 block">TecnologÃ­a de
              Vanguardia</span>
            <h2 class="text-3xl md:text-4xl font-bold text-slate-900 mb-6">Tu Asistente Personal de Viaje</h2>
            <p class="text-slate-600 mb-6">Nuestra asistente virtual, <strong>Sandra IA</strong>, estÃ¡ disponible 24/7
              para mejorar su experiencia. Ahora con capacidad de <strong>videollamada conversacional</strong>.</p>
            <div class="bg-blue-50/40 p-6 rounded-2xl border border-blue-100/50">
              <h4 class="font-bold text-slate-800 mb-2 flex items-center gap-2">
                <svg class="w-5 h-5 text-[#25D366]" fill="currentColor" viewBox="0 0 24 24">
                  <path
                    d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.008-.57-.008-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347z" />
                </svg>
                CertificaciÃ³n WhatsApp Business
              </h4>
              <p class="text-sm text-slate-600">Sandra gestiona consultas cumpliendo con Meta y GDPR. <a href="#legal"
                  class="text-blue-600 nav-link">Leer polÃ­tica</a>.</p>
            </div>
          </div>
          <!-- âš ï¸ LAYOUT PROTECTED: SANDRA VIDEO CALL INTERFACE - NO MODIFICAR SIN AUTORIZACIÃ“N -->
          <div id="sandra-embedded-interface"
            class="relative w-full max-w-xs mx-auto order-1 md:order-2 flex justify-center md:justify-end items-end">
            <div
              class="relative bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 rounded-3xl overflow-hidden shadow-2xl flex flex-col border-2 border-blue-200/50"
              style="aspect-ratio: 9/16; height: 580px; max-height: calc(100vh - 150px);">
              <!-- Header de Videollamada -->
              <div
                class="absolute top-0 left-0 right-0 px-4 pt-3 pb-2 flex justify-between items-center z-20 bg-gradient-to-b from-blue-600/90 to-transparent backdrop-blur-md">
                <div class="flex items-center gap-2">
                  <div class="w-2 h-2 rounded-full bg-green-400 animate-pulse shadow-lg shadow-green-400/50"></div>
                  <span class="text-white text-xs font-semibold">Videollamada</span>
                </div>
                <div class="flex items-center gap-2 bg-white/20 px-2 py-1 rounded-full backdrop-blur-sm">
                  <svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 24 24">
                    <path
                      d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5-6 4.5z" />
                  </svg>
                  <span class="text-white text-[10px] font-medium">24/7</span>
                </div>
              </div>

              <!-- Ãrea Principal de Video -->
              <div
                class="flex-1 relative bg-gradient-to-br from-blue-100 via-indigo-100 to-purple-100 flex items-center justify-center overflow-hidden">
                <!-- Avatar/Placeholder de Video -->
                <div class="absolute inset-0 flex items-center justify-center">
                  <div
                    class="relative w-32 h-32 rounded-full bg-gradient-to-br from-blue-400 via-indigo-400 to-purple-400 flex items-center justify-center shadow-2xl border-4 border-white/50 overflow-hidden">
                    <!-- Selector de carga para avatar -->
                    <label for="sandra-avatar-upload"
                      class="absolute inset-0 flex items-center justify-center cursor-pointer z-10 group">
                      <input type="file" id="sandra-avatar-upload" accept="image/*,video/*" class="hidden">
                      <div
                        class="absolute inset-0 bg-black/0 group-hover:bg-black/20 transition-all flex items-center justify-center">
                        <svg class="w-8 h-8 text-white opacity-0 group-hover:opacity-100 transition-opacity" fill="none"
                          viewBox="0 0 24 24" stroke="currentColor">
                          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                        </svg>
                      </div>
                    </label>
                    <!-- Avatar fijo por defecto (foto) -->
                    <img id="sandra-avatar-image" class="absolute inset-0 w-full h-full object-cover rounded-full"
                      src="assets/images/sandra-avatar.png" alt="Sandra Avatar"
                      onerror="this.style.display='none'; document.getElementById('sandra-avatar-icon').style.display='block';">
                    <!-- Avatar por defecto (icono) - solo si falla la imagen -->
                    <svg id="sandra-avatar-icon" class="w-16 h-16 text-white hidden" fill="none" viewBox="0 0 24 24"
                      stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                    </svg>
                    <!-- Avatar cargado (video) -->
                    <video id="sandra-avatar-video"
                      class="absolute inset-0 w-full h-full object-cover rounded-full hidden" autoplay muted loop
                      playsinline></video>
                  </div>
                  <!-- Ondas de audio animadas -->
                  <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
                    <div class="w-40 h-40 rounded-full border-2 border-blue-300/30 animate-ping"></div>
                    <div class="absolute w-48 h-48 rounded-full border-2 border-indigo-300/20 animate-ping"
                      style="animation-delay: 0.5s;"></div>
                    <div class="absolute w-56 h-56 rounded-full border-2 border-purple-300/10 animate-ping"
                      style="animation-delay: 1s;"></div>
                  </div>
                </div>

                <!-- Video stream (se muestra cuando hay llamada activa) -->
                <img src="/assets/images/sandra-avatar.png" class="absolute inset-0 w-full h-full object-cover hidden"
                  alt="Sandra Avatar" id="sandra-avatar-img"
                  onerror="this.src='https://placehold.co/400x700/3b82f6/ffffff?text=Sandra+IA'">
                <video id="sandra-video-stream" class="absolute inset-0 w-full h-full object-cover hidden"
                  playsinline></video>
                <div id="sandra-voice-pulse"
                  class="absolute w-32 h-32 rounded-full bg-blue-500/30 blur-xl animate-pulse hidden"></div>

                <!-- Indicador de estado -->
                <div
                  class="absolute top-20 left-1/2 transform -translate-x-1/2 bg-white/90 backdrop-blur-md px-4 py-2 rounded-full shadow-lg z-10">
                  <span class="text-blue-600 text-xs font-semibold">
                    LlÃ¡manos
                  </span>
                </div>
              </div>

              <!-- Control Bar (Bottom) - Estilo Gemini -->
              <div
                class="absolute bottom-0 left-0 right-0 pb-4 pt-3 px-4 bg-gradient-to-t from-slate-900/95 via-slate-800/90 to-transparent backdrop-blur-lg">
                <div class="flex items-center justify-center gap-3">
                  <button id="btn-cam-toggle"
                    class="w-10 h-10 rounded-full bg-white/20 hover:bg-white/30 flex items-center justify-center text-white transition-all backdrop-blur-sm border border-white/20">
                    <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                  </button>
                  <button id="btn-mute-toggle"
                    class="w-10 h-10 rounded-full bg-white/20 hover:bg-white/30 flex items-center justify-center text-white transition-all backdrop-blur-sm border border-white/20"
                    title="Silenciar micrÃ³fono">
                    <svg id="mic-icon" class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                    </svg>
                    <svg id="mic-muted-icon" class="w-5 h-5 hidden" fill="none" viewBox="0 0 24 24"
                      stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"
                        clip-rule="evenodd" />
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2" />
                    </svg>
                  </button>
                  <button id="btn-call-toggle"
                    class="w-14 h-14 rounded-full bg-green-500 hover:bg-green-600 flex items-center justify-center text-white shadow-2xl transition-all ring-4 ring-green-500/30">
                    <svg class="w-7 h-7" fill="currentColor" viewBox="0 0 24 24">
                      <path d="M3 21l3-3m0 0V9a6 6 0 0112 0v9m-3-3l3 3m-3-3h6m-6 0V9a3 3 0 00-3-3H9a3 3 0 00-3 3v9" />
                    </svg>
                  </button>
                </div>
              </div>

              <!-- Subtitles -->
              <div id="sandra-subtitles" class="absolute bottom-20 left-0 right-0 text-center px-4 hidden z-30">
                <span
                  class="bg-slate-900/80 backdrop-blur-md text-white px-4 py-2 rounded-xl text-sm font-medium shadow-xl border border-white/10">Espero
                  tu respuesta...</span>
              </div>
            </div>
          </div>
        </div>
      </section>
    </section>

    <!-- [OMITTED SECTIONS FOR BREVITY: ALOJAMIENTOS, SERVICIOS, OWNERS, QUIENES SOMOS, CONTACTO, LEGAL, AUTH] -->
    <!-- (They remain the same as the original, assuming you want the full structure preserved) -->
    <!-- I will inject the SandraWidget code here as per the "workflow" provided -->

  </main>

  <!-- FOOTER -->
  <!-- [SAME FOOTER] -->

  <!-- Persistencia del Hero (solo imagen): aplica + guarda, sin tocar la lÃ³gica de llamada -->
  <script>
      (function () {
        const heroBg = document.getElementById('hero-background-image');
        const heroVideo = document.getElementById('hero-video');
        const heroInput = document.getElementById('hero-media-upload');
        const STORAGE_KEY = 'gv-hero-image';
        let currentObjectUrl = null;

        const applyHeroImage = (url) => {
          if (heroBg) heroBg.style.backgroundImage = `url('${url}')`;
          if (heroVideo) heroVideo.setAttribute('poster', url);
        };

        const revokeCurrentObjectUrl = () => {
          if (currentObjectUrl) {
            URL.revokeObjectURL(currentObjectUrl);
            currentObjectUrl = null;
          }
        };

        // 1) Cargar imagen persistida (localStorage)
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          if (saved) applyHeroImage(saved);
        } catch (err) {
          console.warn('No se pudo leer la imagen guardada del Hero', err);
        }

        // 2) Al subir imagen: mostrar y persistir (sin tocar vÃ­deo/llamada)
        if (heroInput) {
          heroInput.addEventListener('change', (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;

            if (!file.type || !file.type.startsWith('image/')) {
              // No forzamos nada: si no es imagen, salimos sin romper el flujo.
              return;
            }

            // Mostrar al instante
            revokeCurrentObjectUrl();
            currentObjectUrl = URL.createObjectURL(file);
            applyHeroImage(currentObjectUrl);

            // Persistir (dataURL)
            const reader = new FileReader();
            reader.onload = () => {
              try {
                localStorage.setItem(STORAGE_KEY, String(reader.result || ''));
              } catch (err) {
                console.warn('No se pudo guardar la imagen del Hero (localStorage)', err);
              }
            };
            reader.readAsDataURL(file);
          });
        }
      })();
  </script>

  <!-- SANDRA WIDGET SCRIPT -->
  <script>
    // Sandra Gateway Client
    class SandraGateway {
      constructor() {
        // Dynamic base URL detection - En localhost usar servidor MCP directamente
        const isLocalhost = window.location.hostname === 'localhost' ||
          window.location.hostname === '127.0.0.1' ||
          window.location.port === '4042';

        if (isLocalhost) {
          this.baseUrl = 'http://localhost:4042/api';
        } else {
          // FIX: Use absolute URL for Render Backend in production
          this.baseUrl = 'https://pwa-imbf.onrender.com/api';
        }
      }

      async sendMessage(message, role = 'hospitality', model = 'groq') {
        try {
          const response = await fetch(`${this.baseUrl}/sandra/chat`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message, role, model })
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `HTTP ${response.status}`);
          }

          const data = await response.json();
          console.log(`[Chat] Respuesta recibida del modelo: ${data.model || 'groq'}`);
          return data.reply;
        } catch (error) {
          console.error('[Chat] Error:', error);
          throw error;
        }
      }
    }

    // Sandra Widget
    class SandraWidget {
      constructor() {
        this.gateway = new SandraGateway();
        // Forzamos modo estÃ¡tico (sin video). Cuando tengas el mp4 de Sora, pon esto a true.
        this.useVideo = false;
        this.ringTimeout = null;
        this.audioCtx = null;
        this._ringNodes = [];
        this.isOpen = false;
        this.isRecording = false;
        this.isMicrophoneMuted = false;
        this.isSpeaking = false;
        this.awaitingResponse = false;
        this.audioQueue = [];
        this.currentAudio = null;
        this.activeCall = null;
        this.mediaRecorder = null;
        this.stream = null;
        this.recordingSliceMs = 2500;
        this.minRecordedBytes = 6000;
        this.responseWatchdogTimeout = null;
        this._mcpConfigPromise = null;
        this.chatLocked = false;
        this.sttAvailable = null;
        this.sttNoticeShown = false;
        // ðŸš€ FASE 1: AudioWorklet para PCM playback
        this.audioWorkletContext = null;
        this.audioWorkletNode = null;
        this.audioWorkletReady = false;
        // ðŸš€ WEBRTC PIPELINE: Queue greeting audio if received during ringtones
        this.waitingForRingtones = false;
        this.queuedGreeting = null;
        this.init();
      }

      async init() {
        this.createWidgetUI();
        this.bindEvents();
        // ðŸš€ FASE 1: Inicializar AudioWorklet para reproducciÃ³n PCM
        await this.setupAudioWorklet();
        // El servidor usa Deepgram TTS para generar audio y enviarlo al cliente
        // El cliente solo reproduce el audio recibido del servidor (NO usa SpeechSynthesis)
      }

      createWidgetUI() {
        // Eliminar el div placeholder oculto si existe
        const existingRoot = document.getElementById('sandra-widget-root');
        if (existingRoot && existingRoot.classList.contains('hidden')) {
          existingRoot.remove();
        }

        const widgetHTML = `
          <div id="sandra-widget-root" class="fixed bottom-4 right-4 z-50 font-sans">
            <button id="sandra-toggle-btn" class="w-14 h-14 rounded-full bg-gradient-to-r from-blue-600 to-indigo-600 text-white shadow-xl hover:scale-105 transition-transform flex items-center justify-center group overflow-hidden border-2 border-white/20">
              <span class="text-2xl group-hover:hidden">ðŸ’¬</span>
              <img src="assets/images/sandra-avatar.png" onerror="this.style.display='none'" class="hidden group-hover:block w-full h-full object-cover rounded-full">
              <span class="absolute top-0 right-0 w-3 h-3 bg-green-500 border-2 border-white rounded-full"></span>
            </button>

            <div id="sandra-chat-window" class="hidden absolute bottom-16 right-0 w-[320px] h-[450px] bg-white rounded-xl shadow-2xl flex flex-col overflow-hidden border border-slate-200 transform origin-bottom-right transition-all duration-300 scale-95 opacity-0">
              <!-- Header -->
              <div class="p-3 bg-gradient-to-r from-[#0F172A] to-[#1E293B] text-white flex justify-between items-center">
                <div class="flex items-center gap-2 flex-1">
                  <div class="relative">
                    <div class="w-8 h-8 rounded-full bg-gradient-to-tr from-blue-400 to-purple-500 flex items-center justify-center text-sm font-bold">S</div>
                    <div class="absolute bottom-0 right-0 w-2.5 h-2.5 bg-green-400 border-2 border-[#0F172A] rounded-full animate-pulse"></div>
                  </div>
                  <div>
                    <h3 class="font-bold text-xs">Sandra IA</h3>
                    <p class="text-[10px] text-blue-200">Asistente Virtual 24/7</p>
                  </div>
                </div>
                <button id="sandra-close-btn" class="text-white/60 hover:text-white transition-colors text-lg leading-none">âœ•</button>
              </div>

              <!-- Messages -->
              <div id="sandra-messages" class="flex-1 overflow-y-auto p-3 space-y-3 bg-slate-50 scroll-smooth">
                <div class="flex gap-2">
                  <div class="w-6 h-6 rounded-full bg-gradient-to-tr from-blue-400 to-purple-500 flex-shrink-0 flex items-center justify-center text-[10px] text-white font-bold">S</div>
                  <div class="bg-white p-2.5 rounded-xl rounded-tl-none shadow-sm border border-slate-100 text-xs text-slate-700 max-w-[85%]">
                    <p>Â¡Hola! Soy Sandra. Bienvenido a GuestsValencia. Â¿En quÃ© puedo ayudarte hoy?</p>
                  </div>
                </div>

                <!-- BotÃ³n de llamada conversacional (se muestra despuÃ©s del primer mensaje) -->
                <div id="sandra-call-prompt" class="flex gap-2 mt-2">
                  <div class="w-6 h-6 rounded-full bg-gradient-to-tr from-blue-400 to-purple-500 flex-shrink-0 flex items-center justify-center text-[10px] text-white font-bold">S</div>
                  <div class="bg-white p-2.5 rounded-xl rounded-tl-none shadow-sm border border-slate-100 text-xs text-slate-700 max-w-[85%]">
                    <p class="mb-2">Â¿Prefieres una llamada de voz conversacional para entendernos mejor?</p>
                    <div class="flex gap-2 mt-2">
                      <button id="sandra-accept-call" class="px-3 py-1.5 bg-green-600 text-white text-[10px] rounded-lg hover:bg-green-700 transition-colors font-semibold">
                        âœ“ Aceptar llamada
                      </button>
                      <button id="sandra-decline-call" class="px-3 py-1.5 bg-slate-200 text-slate-700 text-[10px] rounded-lg hover:bg-slate-300 transition-colors">
                        Continuar por chat
                      </button>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Typing Indicator -->
              <div id="sandra-typing" class="hidden px-3 py-1.5 text-[10px] text-slate-400 italic">Sandra estÃ¡ escribiendo...</div>

              <!-- Controls -->
              <div class="p-3 bg-white border-t border-slate-100">
                <!-- Call Controls (Hidden by default) -->
                <div id="sandra-call-controls" class="hidden mb-2 flex justify-center items-center gap-2 bg-slate-50 rounded-full px-3 py-2 shadow-sm border border-slate-200">
                  <button id="sandra-hangup-btn" class="p-2 rounded-full bg-red-600 text-white hover:bg-red-700 transition-colors shadow-sm"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 8l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2M3 12a9 9 0 1018 0 9 9 0 00-18 0z" /></svg></button>
                  <button id="sandra-mute-btn" class="p-2 rounded-full bg-slate-400 text-white hover:bg-slate-500 transition-colors shadow-sm"><svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" /></svg></button>
                </div>
                <!-- TranscripciÃ³n en vivo (siempre oculta - solo para uso interno/debug) -->
                <div id="sandra-live-transcript" class="hidden" style="display: none !important;"></div>
                <!-- Input Area -->
                <div class="relative flex items-center gap-1.5">
                  <input type="text" id="sandra-input" placeholder="Escribe tu mensaje..." class="flex-1 bg-slate-100 border-0 rounded-full px-3 py-2 text-xs focus:ring-2 focus:ring-blue-500 focus:bg-white transition-all">
                <!-- <button id="sandra-mic-btn" class="p-2 rounded-full bg-slate-100 text-slate-600 hover:bg-blue-100 hover:text-blue-600 transition-colors">
                  <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" /></svg>
                </button> -->
                  <button id="sandra-send-btn" class="p-2 rounded-full bg-blue-600 text-white hover:bg-blue-700 shadow-lg hover:shadow-blue-500/30 transition-all">
                    <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" /></svg>
                  </button>
                </div>
              </div>
            </div>
          </div>`;

        document.body.insertAdjacentHTML('beforeend', widgetHTML);
      }

      bindEvents() {
        const toggleBtn = document.getElementById('sandra-toggle-btn');
        const closeBtn = document.getElementById('sandra-close-btn');
        const chatWindow = document.getElementById('sandra-chat-window');
        const sendBtn = document.getElementById('sandra-send-btn');
        const input = document.getElementById('sandra-input');
        const micBtn = document.getElementById('sandra-mic-btn');
        const acceptCallBtn = document.getElementById('sandra-accept-call');
        const declineCallBtn = document.getElementById('sandra-decline-call');
        const callPrompt = document.getElementById('sandra-call-prompt');
        const btnCallToggle = document.getElementById('btn-call-toggle');
        const btnMuteToggle = document.getElementById('btn-mute-toggle');
        const btnSearchAi = document.getElementById('btn-search-ai');

        // Toggle Chat
        const toggleChat = () => {
          this.isOpen = !this.isOpen;
          if (this.isOpen) {
            chatWindow.classList.remove('hidden');
            setTimeout(() => {
              chatWindow.classList.remove('scale-95', 'opacity-0');
              chatWindow.classList.add('scale-100', 'opacity-100');
              input.focus();
            }, 10);
          } else {
            chatWindow.classList.remove('scale-100', 'opacity-100');
            chatWindow.classList.add('scale-95', 'opacity-0');
            setTimeout(() => chatWindow.classList.add('hidden'), 300);
          }
        };
        toggleBtn.addEventListener('click', toggleChat);
        closeBtn.addEventListener('click', toggleChat);

        // Send Message
        const sendMessage = async () => {
          // Bloquear envÃ­o de mensajes si hay llamada activa
          if (this.activeCall || this.chatLocked) {
            console.warn('[CHAT] âš ï¸ Chat deshabilitado durante llamada activa');
            return;
          }

          const text = input.value.trim();
          if (!text) return;
          this.addMessage(text, 'user');
          input.value = '';

          // Asegurar que el prompt de llamada estÃ© visible despuÃ©s de enviar mensaje
          if (!this.activeCall && !this.chatLocked) {
            const callPrompt = document.getElementById('sandra-call-prompt');
            if (callPrompt) {
              callPrompt.style.display = 'flex';
              callPrompt.style.visibility = 'visible';
            }
          }

          this.showTyping(true);
          try {
            const response = await this.gateway.sendMessage(text);
            this.showTyping(false);
            this.addMessage(response, 'bot');
          } catch (error) {
            this.showTyping(false);
            this.addMessage("Lo siento, tuve un problema. IntÃ©ntalo de nuevo.", 'bot');
          }
        };
        sendBtn.addEventListener('click', sendMessage);
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' && !this.activeCall && !this.chatLocked) {
            sendMessage();
          }
        });

        // Call Buttons Logic
        if (acceptCallBtn) {
          acceptCallBtn.addEventListener('click', () => {
            this.startConversationalCall();
            // NO ocultar el prompt, solo ocultar cuando hay llamada activa
            const callControls = document.getElementById('sandra-call-controls');
            if (callControls) callControls.classList.remove('hidden');
            // Ocultar prompt solo durante la llamada
            if (callPrompt) callPrompt.style.display = 'none';
            // Hide chat window when starting call
            toggleChat();
          });
        }

        if (declineCallBtn) {
          declineCallBtn.addEventListener('click', () => {
            // NO ocultar el prompt, debe estar siempre visible
            // Solo ocultar si el usuario declina explÃ­citamente
            // if (callPrompt) callPrompt.style.display = 'none';
            // Logic to continue chat only
          });
        }

        // Hangup button listener
        const hangupBtn = document.getElementById('sandra-hangup-btn');
        if (hangupBtn) {
          hangupBtn.addEventListener('click', () => {
            this.hangupCall('user');
          });
        }

        if (btnCallToggle) {
          btnCallToggle.addEventListener('click', () => {
            // Toggle logic: for now, it starts call if not started
            if (!this.activeCall) {
              this.startConversationalCall();
            } else {
              // Hang up
              try { this.activeCall.close(); } catch (_) { }
              this.activeCall = null;
              this.stopAudioCapture();
              this.setHeroCallActive(false);
              console.log("Call ended by user");
              // Optionally reset UI to idle state
            }
          });
        }

        if (btnMuteToggle) {
          btnMuteToggle.addEventListener('click', () => {
            this.isMicrophoneMuted = !this.isMicrophoneMuted;
            const micIcon = document.getElementById('mic-icon');
            const micMutedIcon = document.getElementById('mic-muted-icon');
            if (this.isMicrophoneMuted) {
              micIcon && micIcon.classList.add('hidden');
              micMutedIcon && micMutedIcon.classList.remove('hidden');
              btnMuteToggle.classList.add('bg-red-500/40');
            } else {
              micMutedIcon && micMutedIcon.classList.add('hidden');
              micIcon && micIcon.classList.remove('hidden');
              btnMuteToggle.classList.remove('bg-red-500/40');
            }
          });
        }

        // Removed: btn-search-ai functionality - calls are now only available through the widget
        // if (btnSearchAi) {
        //   btnSearchAi.addEventListener('click', () => {
        //     this.startConversationalCall();
        //   });
        // }
      }

      setHeroCallActive(active) {
        const heroBg = document.getElementById('hero-background-image');
        const heroVideo = document.getElementById('hero-video');
        const searchContainer = document.getElementById('search-container');

        if (searchContainer) {
          searchContainer.style.opacity = active ? '0' : '1';
          searchContainer.style.pointerEvents = active ? 'none' : 'auto';
        }

        if (heroBg) {
          heroBg.classList.toggle('hero-motion', !!active);
        }

        // En modo sin video, aseguramos que el <video> no se muestre ni cargue.
        if (heroVideo && !this.useVideo) {
          try {
            heroVideo.pause();
            heroVideo.currentTime = 0;
          } catch (_) { }
          heroVideo.style.display = 'none';
          heroVideo.style.opacity = '0';
          const source = heroVideo.querySelector('source');
          if (source) source.removeAttribute('src');
          try { heroVideo.load(); } catch (_) { }
        }

        if (!active) {
          this.chatLocked = false;
          if (this.ringTimeout) {
            clearTimeout(this.ringTimeout);
            this.ringTimeout = null;
          }
        }
      }

      async startConversationalCall() {
        console.log('Iniciando llamada conversacional...');
        if (this.chatLocked || this.activeCall || this.ringTimeout) return;
        this.chatLocked = true;

        // Deshabilitar input del chat cuando hay llamada activa
        const input = document.getElementById('sandra-input');
        const sendBtn = document.getElementById('sandra-send-btn');
        if (input) {
          input.disabled = true;
          input.placeholder = 'Llamada activa - El chat estÃ¡ deshabilitado';
        }
        if (sendBtn) {
          sendBtn.disabled = true;
        }

        // Ocultar prompt de llamada cuando inicia
        const callPrompt = document.getElementById('sandra-call-prompt');
        if (callPrompt) callPrompt.style.display = 'none';

        // Mostrar controles de llamada
        const callControls = document.getElementById('sandra-call-controls');
        if (callControls) callControls.classList.remove('hidden');

        // ðŸš€ WEBRTC PIPELINE: Establecer conexiÃ³n WebSocket PRIMERO, luego ringtones
        // Connection will trigger ringtones in ws.onopen
        await this.startRealTimeCall();
      }

      ensureAudioContext() {
        if (this.audioCtx) return this.audioCtx;
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return null;
        this.audioCtx = new Ctx();
        return this.audioCtx;
      }

      stopRingtone() {
        if (this.ringTimeout) {
          clearTimeout(this.ringTimeout);
          this.ringTimeout = null;
        }
        if (this._ringNodes && this._ringNodes.length) {
          for (const n of this._ringNodes) {
            try { if (typeof n.stop === 'function') n.stop(0); } catch (_) { }
            try { if (typeof n.disconnect === 'function') n.disconnect(); } catch (_) { }
          }
          this._ringNodes = [];
        }
      }

      playRingtone() {
        // ðŸš€ ELIMINADO: CÃ³digo legacy que causaba llamadas duplicadas
        // Este mÃ©todo ya no inicia llamadas - solo reproduce ringtones
        // Las llamadas se inician desde startConversationalCall() -> startRealTimeCall()
        console.warn('[LEGACY] playRingtone() llamado - mÃ©todo legacy, no debe iniciar llamadas');
        this.playRingtoneAfterConnection(() => {
          // Solo actualizar UI, NO iniciar llamada (ya se iniciÃ³ desde startConversationalCall)
          if (!this.chatLocked) return;
          console.log('ðŸ”” Segundo ring completado');
          this.setHeroCallActive(true);
        });
      }

      playRingtoneAfterConnection(callback) {
        console.log('ðŸ”” Iniciando ringtone despuÃ©s de conexiÃ³n establecida...');
        this.stopRingtone();

        const ctx = this.ensureAudioContext();
        if (!ctx) {
          // Fallback if no audio context
          this.ringTimeout = setTimeout(() => {
            this.ringTimeout = null;
            if (callback) callback();
          }, 3000);
          return;
        }

        try { if (ctx.state === 'suspended') ctx.resume(); } catch (_) { }

        const scheduleRing = (start, dur, freq = 425) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, start);
          gain.gain.setValueAtTime(0.0001, start);
          gain.gain.exponentialRampToValueAtTime(0.18, start + 0.02);
          gain.gain.setValueAtTime(0.18, start + Math.max(0.05, dur - 0.04));
          gain.gain.exponentialRampToValueAtTime(0.0001, start + dur);
          osc.connect(gain).connect(ctx.destination);
          osc.start(start);
          osc.stop(start + dur);
          this._ringNodes.push(osc, gain);
        };

        const scheduleClac = (t) => {
          const len = Math.floor(ctx.sampleRate * 0.03);
          const buffer = ctx.createBuffer(1, len, ctx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < len; i++) {
            const env = Math.exp(-i / (len / 6));
            data[i] = (Math.random() * 2 - 1) * env;
          }
          const src = ctx.createBufferSource();
          const gain = ctx.createGain();
          src.buffer = buffer;
          gain.gain.setValueAtTime(0.35, t);
          gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.03);
          src.connect(gain).connect(ctx.destination);
          src.start(t);
          src.stop(t + 0.04);
          this._ringNodes.push(src, gain);
        };

        const now = ctx.currentTime + 0.02;
        const dur = 1.15;
        const gap = 0.35;
        scheduleRing(now, dur);
        scheduleRing(now + dur + gap, dur);
        scheduleClac(now + (dur * 2) + gap + 0.05);

        const totalMs = Math.ceil(((dur * 2) + gap + 0.25) * 1000);
        this.ringTimeout = setTimeout(() => {
          this.ringTimeout = null;
          if (!this.chatLocked) {
            if (callback) callback();
            return;
          }
          console.log('ðŸ”” Segundo ring completado, llamada lista');
          this.setHeroCallActive(true);
          if (callback) callback();
        }, totalMs);
      }

      transitionHeroToVideo() {
        console.log('ðŸŽ¥ TransiciÃ³n: Imagen estÃ¡tica â†’ Video');
        if (!this.useVideo) return;
        const heroImage = document.getElementById('hero-background-image');
        const heroVideo = document.getElementById('hero-video');

        if (heroImage && heroVideo) {
          // Crossfade SIN "cortina blanca": mantenemos la imagen visible y hacemos fade-in del vÃ­deo encima.
          // AdemÃ¡s, igualamos el poster del vÃ­deo al fondo actual para que el cambio sea casi imperceptible.
          try {
            const bg = window.getComputedStyle(heroImage).backgroundImage || '';
            const m = bg.match(/url\(["']?(.*?)["']?\)/i);
            if (m && m[1]) heroVideo.setAttribute('poster', m[1]);
          } catch (_) { }

          heroImage.style.display = 'block';
          heroImage.style.opacity = '1';

          heroVideo.style.display = 'block';
          heroVideo.style.opacity = '0';
          heroVideo.style.transition = 'opacity 0.8s ease-in';

          requestAnimationFrame(() => {
            heroVideo.style.opacity = '1';
          });
        }
      }

      startVideoStream() {
        console.log('ðŸŽ¬ Iniciando stream de video...');
        // ðŸš€ ELIMINADO: Llamada duplicada a startRealTimeCall()
        // La llamada ya se iniciÃ³ desde startConversationalCall() -> startRealTimeCall()
        // Este mÃ©todo solo maneja el video, NO debe iniciar la llamada
        
        if (!this.useVideo) {
          // Si no hay video, solo actualizar UI - la llamada ya estÃ¡ activa
          return;
        }
        
        const heroVideo = document.getElementById('hero-video');
        const videoSource = heroVideo.querySelector('source');

        if (heroVideo && videoSource) {
          videoSource.src = 'assets/videos/sandra-call-1.mp4';
          heroVideo.load();
          heroVideo.play().catch(e => console.log('Error al reproducir video:', e));
        }
        // ðŸš€ NO llamar startRealTimeCall() aquÃ­ - ya se llamÃ³ desde startConversationalCall()
      }

      async getMcpConfig() {
        if (this._mcpConfigPromise) return this._mcpConfigPromise;
        this._mcpConfigPromise = (async () => {
          try {
            const res = await fetch('/api/config', { cache: 'no-store' });
            if (!res.ok) throw new Error(`config ${res.status}`);
            const cfg = await res.json();
            return {
              MCP_SERVER_URL: cfg && cfg.MCP_SERVER_URL ? cfg.MCP_SERVER_URL : 'https://pwa-imbf.onrender.com',
              MCP_TOKEN: cfg && cfg.MCP_TOKEN ? cfg.MCP_TOKEN : null
            };
          } catch (err) {
            console.warn('[MCP] No se pudo cargar /api/config, usando fallback', err);
            return { MCP_SERVER_URL: 'https://pwa-imbf.onrender.com', MCP_TOKEN: null };
          }
        })();
        return this._mcpConfigPromise;
      }

      buildWebSocketUrl(mcpServerUrl, token) {
        // En localhost, usar ws://localhost:4042
        if (mcpServerUrl && (mcpServerUrl.includes('localhost') || mcpServerUrl.includes('127.0.0.1'))) {
          return 'ws://localhost:4042';
        }
        let url;
        try {
          url = new URL(String(mcpServerUrl || ''));
        } catch (_) {
          url = new URL('https://pwa-imbf.onrender.com');
        }

        const isRender = url.hostname.includes('onrender.com');

        // FIX: Force WSS for Render to avoid Mixed Content
        if (isRender) {
          url.protocol = 'wss:';
          // Render usa WebSocket en el mismo puerto, pero con path /ws normalmente
          // Si no funciona, probar sin especificar puerto
          url.port = '';
          url.pathname = '/'; // Algunos servidores usan /ws, otros /
        } else {
          url.protocol = (url.protocol === 'https:') ? 'wss:' : 'ws:';
          if (!url.port) url.port = '4042';
          url.pathname = '/';
        }

        url.search = token ? `?token=${encodeURIComponent(String(token))}` : '';
        const finalUrl = url.toString();
        console.log('[MCP] URL WebSocket final:', finalUrl);
        return finalUrl;
      }

      clearResponseWatchdog() {
        if (this.responseWatchdogTimeout) {
          clearTimeout(this.responseWatchdogTimeout);
          this.responseWatchdogTimeout = null;
        }
      }

      startResponseWatchdog() {
        this.clearResponseWatchdog();
        this.responseWatchdogTimeout = setTimeout(() => {
          this.responseWatchdogTimeout = null;
          if (!this.activeCall) return;
          if (!this.awaitingResponse) return;
          console.warn('[MCP] Watchdog: sin respuesta, reanudando escucha');
          this.awaitingResponse = false;
        }, 12000);
      }

      hangupCall(reason = 'unknown') {
        if (this.sttAvailable === false && reason !== 'user' && reason !== 'mic_error') {
          console.log('ðŸ“ž Hangup ignorado (STT desactivado)', { reason });
          return;
        }
        console.log('ðŸ“ž Colgando llamada...', { reason });

        // ðŸš€ CRÃTICO: Detener audio inmediatamente (arregla bug de llamada que no se cierra)
        if (this.currentAudio) {
          try {
            this.currentAudio.pause();
            this.currentAudio.currentTime = 0;
            if (this.currentAudio._blobUrl) {
              URL.revokeObjectURL(this.currentAudio._blobUrl);
              this.currentAudio._blobUrl = null;
            }
            this.currentAudio = null;
            console.log('[HANGUP] âœ… Audio detenido y limpiado');
          } catch (error) {
            console.error('[HANGUP] Error deteniendo audio:', error);
          }
        }

        // Cerrar WebSocket
        if (this.activeCall) {
          try {
            this.activeCall.close();
          } catch (_) { }
          this.activeCall = null;
        }

        // Detener captura de audio
        this.stopAudioCapture();

        // Limpiar estado
        this.chatLocked = false;
        this.setHeroCallActive(false);
        this.awaitingResponse = false;
        this.isSpeaking = false;

        // ðŸš€ ENTERPRISE: Limpiar barge-in detection
        this.cleanupBargeIn();

        // Reactivar input del chat cuando se cierra la llamada
        const input = document.getElementById('sandra-input');
        const sendBtn = document.getElementById('sandra-send-btn');
        if (input) {
          input.disabled = false;
          input.placeholder = 'Escribe tu mensaje...';
        }
        if (sendBtn) {
          sendBtn.disabled = false;
        }

        // Ocultar controles de llamada
        const callControls = document.getElementById('sandra-call-controls');
        if (callControls) callControls.classList.add('hidden');

        const liveTranscript = document.getElementById('sandra-live-transcript');
        if (liveTranscript) {
          liveTranscript.classList.add('hidden');
          liveTranscript.textContent = '';
        }

        // SIEMPRE mostrar prompt de llamada cuando se cuelga
        const callPrompt = document.getElementById('sandra-call-prompt');
        if (callPrompt) {
          callPrompt.style.display = 'flex';
          callPrompt.style.visibility = 'visible';
        }

        console.log('âœ… Llamada colgada correctamente');
      }

      stopAudioCapture() {
        this.clearResponseWatchdog();
        this.awaitingResponse = false;
        // NO cambiar isSpeaking aquÃ­ - el audio debe terminar naturalmente
        // this.isSpeaking = false; // REMOVED - permite que el audio termine completo

        // ðŸš€ ENTERPRISE: Limpiar barge-in detection
        this.cleanupBargeIn();

        if (this.pcmProcessor) {
          try { this.pcmProcessor.disconnect(); } catch (_) { }
          try { this.pcmProcessor.onaudioprocess = null; } catch (_) { }
          this.pcmProcessor = null;
        }

        if (this.pcmSource) {
          try { this.pcmSource.disconnect(); } catch (_) { }
          this.pcmSource = null;
        }

        if (this.pcmSilenceGain) {
          try { this.pcmSilenceGain.disconnect(); } catch (_) { }
          this.pcmSilenceGain = null;
        }

        if (this.pcmAudioContext) {
          try { this.pcmAudioContext.close(); } catch (_) { }
          this.pcmAudioContext = null;
        }

        if (this.mediaRecorder) {
          try {
            if (this.mediaRecorder.state === 'recording' || this.mediaRecorder.state === 'paused') {
              this.mediaRecorder.stop();
            }
          } catch (_) { }
          this.mediaRecorder = null;
        }

        if (this.stream) {
          try {
            this.stream.getTracks().forEach(t => t.stop());
          } catch (_) { }
          this.stream = null;
        }
      }

      async startRealTimeCall() {
        // ðŸš€ PROTECCIÃ“N: Verificar que no hay una llamada activa antes de crear nueva conexiÃ³n
        if (this.activeCall && (this.activeCall.readyState === WebSocket.CONNECTING || this.activeCall.readyState === WebSocket.OPEN)) {
          console.warn('[MCP] âš ï¸ Ya hay una llamada activa, ignorando llamada duplicada');
          return;
        }

        // Ocultar prompt de llamada cuando inicia la llamada real
        const callPrompt = document.getElementById('sandra-call-prompt');
        if (callPrompt) callPrompt.style.display = 'none';

        // Desactivar input del chat cuando hay llamada activa
        const input = document.getElementById('sandra-input');
        const sendBtn = document.getElementById('sandra-send-btn');
        if (input) {
          input.disabled = true;
          input.placeholder = 'Llamada activa...';
        }
        if (sendBtn) {
          sendBtn.disabled = true;
        }

        console.log('[MCP] Iniciando llamada en tiempo real...');
        const cfg = await this.getMcpConfig();
        console.log('[MCP] ConfiguraciÃ³n cargada:', { url: cfg.MCP_SERVER_URL, hasToken: !!cfg.MCP_TOKEN });
        const wsUrl = this.buildWebSocketUrl(cfg.MCP_SERVER_URL, cfg.MCP_TOKEN);
        console.log('[MCP] URL WebSocket construida:', wsUrl);
        const ws = new WebSocket(wsUrl);
        this.activeCall = ws;
        this.sttAvailable = null;
        this.sttNoticeShown = false;

        // NOTE: Ya desactivamos input/sendBtn arriba. No redeclarar variables aquÃ­:
        // redeclarar `const input` en el mismo scope rompe el script con SyntaxError.
        let sttCapabilitiesTimeout = null;
        let microphoneStartPromise = null;
        let microphoneStarted = false;

        const clearSttCapabilitiesTimeout = () => {
          if (sttCapabilitiesTimeout) {
            clearTimeout(sttCapabilitiesTimeout);
            sttCapabilitiesTimeout = null;
          }
        };

        const startMicrophoneCapture = async () => {
          if (microphoneStarted || microphoneStartPromise) return microphoneStartPromise;
          if (!this.activeCall || this.activeCall !== ws || ws.readyState !== WebSocket.OPEN) return null;
          if (this.sttAvailable === false) return null;

          microphoneStartPromise = (async () => {
            try {
              const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                  echoCancellation: true,
                  noiseSuppression: true,
                  autoGainControl: true,
                  channelCount: 1
                }
              });

              this.stream = stream;

              const startPcmStreaming = async () => {
                const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
                if (!AudioContextCtor) return false;

                const downsampleBuffer = (buffer, inSampleRate, outSampleRate) => {
                  if (!buffer || !buffer.length) return new Float32Array(0);
                  if (outSampleRate === inSampleRate) return buffer;
                  if (outSampleRate > inSampleRate) return buffer;

                  const sampleRateRatio = inSampleRate / outSampleRate;
                  const newLength = Math.round(buffer.length / sampleRateRatio);
                  const result = new Float32Array(newLength);
                  let offsetResult = 0;
                  let offsetBuffer = 0;

                  while (offsetResult < result.length) {
                    const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
                    let accum = 0;
                    let count = 0;
                    for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
                      accum += buffer[i];
                      count++;
                    }
                    result[offsetResult] = count ? (accum / count) : 0;
                    offsetResult++;
                    offsetBuffer = nextOffsetBuffer;
                  }
                  return result;
                };

                const arrayBufferToBase64 = (arrayBuffer) => {
                  const bytes = new Uint8Array(arrayBuffer);
                  let binary = '';
                  const chunkSize = 0x8000;
                  for (let i = 0; i < bytes.length; i += chunkSize) {
                    binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
                  }
                  return btoa(binary);
                };

                try {
                  const ctx = new AudioContextCtor();
                  this.pcmAudioContext = ctx;

                  if (ctx.state === 'suspended') {
                    try { await ctx.resume(); } catch (_) { }
                  }

                  const source = ctx.createMediaStreamSource(stream);
                  const processor = ctx.createScriptProcessor(4096, 1, 1);
                  const silenceGain = ctx.createGain();
                  silenceGain.gain.value = 0;

                  source.connect(processor);
                  processor.connect(silenceGain);
                  silenceGain.connect(ctx.destination);

                  this.pcmSource = source;
                  this.pcmProcessor = processor;
                  this.pcmSilenceGain = silenceGain;

                  // ðŸš€ ENTERPRISE: Configurar barge-in avanzado (despuÃ©s de crear contexto de audio)
                  this.setupBargeInDetection(ctx, stream);

                  const targetSampleRate = 48000; // âœ… Actualizado segÃºn JSON Deepgram Playground (48000 Hz input)
                  const chunkMs = 250;
                  const chunkSamples = Math.round(targetSampleRate * (chunkMs / 1000));
                  let chunkBuffer = new Int16Array(chunkSamples);
                  let chunkIndex = 0;

                  processor.onaudioprocess = (e) => {
                    try {
                      if (!this.activeCall || ws.readyState !== WebSocket.OPEN) return;
                      if (this.sttAvailable === false) return;

                      // ðŸš€ FULL DUPLEX: Solo bloquear si el micrÃ³fono estÃ¡ explÃ­citamente mutado
                      // Permitir que el usuario hable mientras la IA habla (full duplex real)
                      if (this.isMicrophoneMuted) {
                        chunkIndex = 0;
                        return;
                      }
                      
                      // ðŸš€ GPT-4o: Verificar si necesitamos enviar silencio (usuario callÃ³)
                      const now = Date.now();
                      const timeSinceLastAudio = now - (this.lastAudioSentAt || 0);
                      // Si han pasado mÃ¡s de 500ms sin audio, iniciar timer de silencio
                      if (timeSinceLastAudio > 500 && !this.silenceKeepAliveTimer) {
                        this.silenceKeepAliveTimer = setTimeout(() => {
                          // Enviar chunk de silencio para mantener conexiÃ³n activa
                          if (ws.readyState === WebSocket.OPEN && this.activeCall === ws) {
                            const silenceChunk = new Int16Array(chunkSamples); // Ya estÃ¡ lleno de ceros (silencio)
                            const base64Silence = arrayBufferToBase64(silenceChunk.buffer);
                            const silenceMessage = {
                              route: 'audio',
                              action: 'stt',
                              payload: {
                                audio: base64Silence,
                                format: 'linear16',
                                encoding: 'linear16',
                                sampleRate: targetSampleRate,
                                channels: 1,
                                mimeType: 'audio/raw',
                                sessionId: this.sessionId,
                                isSilence: true // ðŸš€ GPT-4o: Marcar como silencio para logging
                              }
                            };
                            ws.send(JSON.stringify(silenceMessage));
                            this.lastAudioSentAt = Date.now();
                            console.log(`[PIPELINE ROBUSTO] ðŸ”‡ Enviando silencio keepalive (${timeSinceLastAudio}ms sin audio)`);
                            this.silenceKeepAliveTimer = null; // Reset timer
                          }
                        }, 1000); // Enviar silencio cada 1s si no hay audio
                      }

                      const input = e.inputBuffer.getChannelData(0);
                      const downsampled = downsampleBuffer(input, ctx.sampleRate, targetSampleRate);

                      for (let i = 0; i < downsampled.length; i++) {
                        const sample = Math.max(-1, Math.min(1, downsampled[i]));
                        chunkBuffer[chunkIndex++] = sample < 0 ? sample * 0x8000 : sample * 0x7fff;

                        if (chunkIndex >= chunkSamples) {
                          const base64Audio = arrayBufferToBase64(chunkBuffer.buffer);
                          const audioMessage = {
                            route: 'audio',
                            action: 'stt',
                            payload: {
                              audio: base64Audio,
                              format: 'linear16',
                              encoding: 'linear16',
                              sampleRate: targetSampleRate,
                              channels: 1,
                              mimeType: 'audio/raw',
                              sessionId: this.sessionId // ðŸš€ PIPELINE ROBUSTO: Incluir sessionId
                            }
                          };
                          
                          // ðŸš€ PIPELINE ROBUSTO: Almacenar en buffer para reenvÃ­o en caso de corte
                          // ðŸš€ LIMPIEZA: Solo agregar al buffer si no estÃ¡ lleno o si es un chunk nuevo
                          if (this.audioBuffer.length < this.maxBufferSize) {
                            this.audioBuffer.push(audioMessage);
                          } else {
                            // Buffer lleno: reemplazar el mÃ¡s antiguo (FIFO)
                            this.audioBuffer.shift();
                            this.audioBuffer.push(audioMessage);
                          }
                          
                          // ðŸš€ GPT-4o: Actualizar timestamp de Ãºltimo audio enviado
                          this.lastAudioSentAt = Date.now();
                          
                          // ðŸš€ GPT-4o: Cancelar timer de silencio si hay audio real
                          if (this.silenceKeepAliveTimer) {
                            clearTimeout(this.silenceKeepAliveTimer);
                            this.silenceKeepAliveTimer = null;
                          }
                          
                          // Enviar si la conexiÃ³n estÃ¡ abierta
                          if (ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify(audioMessage));
                            console.log(`[PIPELINE ROBUSTO] ðŸ“¤ Audio enviado (buffer: ${this.audioBuffer.length}/${this.maxBufferSize} chunks)`);
                          } else {
                            // ðŸš€ LIMPIEZA: Si la conexiÃ³n no estÃ¡ abierta, no enviar pero mantener en buffer
                            console.warn(`[PIPELINE ROBUSTO] âš ï¸ WebSocket no estÃ¡ abierto (readyState: ${ws.readyState}), chunk guardado en buffer`);
                          }
                          
                          chunkBuffer = new Int16Array(chunkSamples);
                          chunkIndex = 0;
                        }
                      }
                    } catch (err) {
                      console.error('[MCP] Error en PCM onaudioprocess', err);
                    }
                  };

                  console.log(`[MCP] ðŸŽ¤ Captura PCM iniciada (linear16 ${targetSampleRate}Hz)`);
                  // #region agent log - debug removed
                  // #endregion
                  return true;
                } catch (err) {
                  console.warn('[MCP] PCM no disponible, fallback a MediaRecorder', err);
                  try { if (this.pcmProcessor) this.pcmProcessor.disconnect(); } catch (_) { }
                  try { if (this.pcmSource) this.pcmSource.disconnect(); } catch (_) { }
                  try { if (this.pcmSilenceGain) this.pcmSilenceGain.disconnect(); } catch (_) { }
                  try { if (this.pcmAudioContext) this.pcmAudioContext.close(); } catch (_) { }
                  this.pcmProcessor = null;
                  this.pcmSource = null;
                  this.pcmSilenceGain = null;
                  this.pcmAudioContext = null;
                  return false;
                }
              };

              const pcmStarted = await startPcmStreaming();

              if (!pcmStarted) {
                const preferredMime = 'audio/webm;codecs=opus';
                let actualMimeType = preferredMime;
                try {
                  if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(preferredMime)) {
                    this.mediaRecorder = new MediaRecorder(stream, { mimeType: preferredMime });
                  } else {
                    this.mediaRecorder = new MediaRecorder(stream);
                    actualMimeType = this.mediaRecorder.mimeType || 'audio/webm';
                  }
                } catch (_) {
                  this.mediaRecorder = new MediaRecorder(stream);
                  actualMimeType = this.mediaRecorder.mimeType || 'audio/webm';
                }

                this.mediaRecorder.ondataavailable = (event) => {
                  try {
                    if (!event.data || event.data.size <= 0) return;
                    if (!this.activeCall || ws.readyState !== WebSocket.OPEN) return;
                    if (this.sttAvailable === false) return;
                    // ðŸš€ FULL DUPLEX: Solo bloquear si el micrÃ³fono estÃ¡ explÃ­citamente mutado
                    // Permitir que el usuario hable mientras la IA habla (full duplex real)
                    if (this.isMicrophoneMuted) return;

                    // Convertir audio a base64 y enviar como JSON
                    const reader = new FileReader();
                    reader.onloadend = () => {
                      if (ws.readyState === WebSocket.OPEN) {
                        try {
                          // Convertir ArrayBuffer a base64
                          const arrayBuffer = reader.result;
                          const bytes = new Uint8Array(arrayBuffer);
                          let binary = '';
                          for (let i = 0; i < bytes.byteLength; i++) {
                            binary += String.fromCharCode(bytes[i]);
                          }
                          const base64Audio = btoa(binary);

                          // Enviar como JSON segÃºn la especificaciÃ³n
                          ws.send(JSON.stringify({
                            route: 'audio',
                            action: 'stt',
                            payload: {
                              audio: base64Audio,
                              format: 'webm',
                              mimeType: actualMimeType
                            }
                          }));
                          console.log('[MCP] Audio enviado como JSON base64, tamaÃ±o:', base64Audio.length);
                        } catch (err) {
                          console.error('[MCP] Error convirtiendo audio a base64:', err);
                        }
                      }
                    };
                    reader.readAsArrayBuffer(event.data);

                  } catch (err) {
                    console.error('[MCP] Error en ondataavailable', err);
                  }
                };

                this.mediaRecorder.start(1000); // Slices de 1000ms (1 segundo) para mejor compatibilidad con Deepgram
              }
              microphoneStarted = true;
              console.log('ðŸŽ¤ Microphone recording started (Enterprise Streaming)');

            } catch (err) {
              console.error('[MCP] âŒ Error accediendo al micrÃ³fono:', err);
              
              // Manejar diferentes tipos de errores
              let errorMessage = 'No se pudo acceder al micrÃ³fono.';
              if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                errorMessage = 'Por favor, permite el acceso al micrÃ³fono en la configuraciÃ³n de tu navegador.';
              } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                errorMessage = 'No se encontrÃ³ ningÃºn micrÃ³fono. Por favor, conecta un micrÃ³fono.';
              } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                errorMessage = 'El micrÃ³fono estÃ¡ siendo usado por otra aplicaciÃ³n.';
              }
              
              // Mostrar mensaje al usuario en el chat en lugar de alert
              const messagesContainer = document.getElementById('sandra-messages');
              if (messagesContainer) {
                const errorHtml = `
                  <div class="flex gap-2">
                    <div class="w-6 h-6 rounded-full bg-gradient-to-tr from-blue-400 to-purple-500 flex-shrink-0 flex items-center justify-center text-[10px] text-white font-bold">S</div>
                    <div class="bg-white p-2.5 rounded-xl rounded-tl-none shadow-sm border border-red-200 text-xs text-red-700 max-w-[85%]">
                      <p>âš ï¸ ${errorMessage}</p>
                      <p class="mt-1 text-[10px] text-red-600">La llamada de voz requiere acceso al micrÃ³fono.</p>
                    </div>
                  </div>`;
                messagesContainer.insertAdjacentHTML('beforeend', errorHtml);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
              }
              
              this.stopAudioCapture();
              this.hangupCall('mic_error');
            } finally {
              microphoneStartPromise = null;
            }
          })();

          return microphoneStartPromise;
        };

        ws.onopen = async () => {
          console.log('âœ… WebSocket conectado (Enterprise Mode)', wsUrl);

          // ðŸš€ PIPELINE ROBUSTO: Si es reconexiÃ³n, enviar resume_session
          if (this.reconnectAttempts > 0 && this.sessionId) {
            console.log(`[MCP] ðŸ”„ Reanudando sesiÃ³n ${this.sessionId}...`);
          ws.send(JSON.stringify({
            route: 'conserje',
            action: 'message',
              payload: { 
                type: 'resume_session', 
                sessionId: this.sessionId,
                message: 'Cliente reconectado - reanudando sesiÃ³n' 
              }
            }));
            // En reconexiÃ³n, no reproducir ringtones, solo reanudar micrÃ³fono
            setTimeout(() => {
              if (this.sttAvailable === null) this.sttAvailable = true;
              console.log('[MCP] ðŸŽ¤ Reanudando captura de micrÃ³fono despuÃ©s de reconexiÃ³n');
              startMicrophoneCapture();
            }, 500);
            return;
          }

          // ðŸš€ WEBRTC PIPELINE: Play ringtones AFTER connection is established
          console.log('[MCP] ðŸš€ Connection established - playing ringtones before greeting');
          this.waitingForRingtones = true;
          this.queuedGreeting = null;
          
          // Send ready signal (server will send greeting, but we'll queue it)
          ws.send(JSON.stringify({
            route: 'conserje',
            action: 'message',
            payload: { type: 'ready', message: 'Cliente listo - esperando ringtones' }
          }));

          // ðŸš€ REAL-TIME PIPELINE: DespuÃ©s de ringtones, reproducir saludo en cola, luego iniciar micrÃ³fono
          this.playRingtoneAfterConnection(() => {
            // Callback after ringtones complete
            console.log('[MCP] ðŸ”” Ringtones completed - verificando saludo en cola');
            this.waitingForRingtones = false;
            
            // ðŸš€ FIX: Reproducir saludo en cola si existe
            if (this.queuedGreeting && this.queuedGreeting.audio) {
              console.log('[MCP] ðŸ”Š Reproduciendo saludo en cola despuÃ©s de ringtones');
              const queuedAudio = this.queuedGreeting.audio;
              const queuedIsWelcome = this.queuedGreeting.isWelcome;
              this.queuedGreeting = null; // Limpiar despuÃ©s de guardar
              this.playAudioResponse(queuedAudio, queuedIsWelcome);
            } else {
              console.log('[MCP] â„¹ï¸ No hay saludo en cola para reproducir');
            }
            
            // âœ… 1 segundo de silencio despuÃ©s de ringtones, luego iniciar micrÃ³fono
            // El usuario habla y Sandra responde naturalmente (sin saludo predeterminado)
            setTimeout(() => {
          sttCapabilitiesTimeout = setTimeout(() => {
            if (this.sttAvailable === false) return;
            if (this.sttAvailable === null) this.sttAvailable = true;
                console.log('[MCP] ðŸŽ¤ Iniciando captura de micrÃ³fono - listo para conversaciÃ³n natural');
            startMicrophoneCapture();
              }, 100); // PequeÃ±o delay adicional para estabilizaciÃ³n
            }, 1000); // 1 segundo de silencio despuÃ©s de ringtones
          });
        };

        ws.onmessage = async (event) => {
          // Solo manejar JSON (el servidor envÃ­a audio como JSON con base64)
          let data;
          try {
            // Si es Blob, convertir a texto primero
            if (event.data instanceof Blob) {
              const text = await event.data.text();
              data = JSON.parse(text);
            } else if (typeof event.data === 'string') {
              data = JSON.parse(event.data);
            } else {
              console.warn('[MCP] Tipo de dato no esperado:', typeof event.data);
              return;
            }

            // PRIMERO: Ignorar errores "Unknown message type" del servidor ANTES de loguear (no son crÃ­ticos)
            // Estos errores vienen del servidor cuando no reconoce el formato, pero no son crÃ­ticos para el cliente
            if (data && data.type === 'error' && data.error && typeof data.error === 'string') {
              if (data.error.includes('Unknown message type')) {
                // Silenciar completamente estos errores - no loguear NADA
                return;
              }
            }

            // Mostrar el mensaje completo para diagnosticar (solo si no es un error ignorado)
            console.log('[MCP] Mensaje recibido del servidor - COMPLETO:', JSON.stringify(data, null, 2));
          } catch (err) {
            console.error('[MCP] Error parseando mensaje:', err, 'Raw:', event.data);
            return;
          }

          // Manejar mensaje de conexiÃ³n del sistema
          if (data.route === 'system' && data.action === 'connected') {
            console.log('[MCP] âœ… Conectado al servidor MCP, clientId:', data.clientId);
            return;
          }

          // VerificaciÃ³n adicional (ya manejado arriba, pero por seguridad)
          if (data.type === 'error' && data.error && (
            data.error.includes('Unknown message type') || 
            data.error.includes('Unknown message type: undefined')
          )) {
            return;
          }

          // ðŸš€ PIPELINE CALL CENTER: Ignorar TODOS los mensajes que puedan causar cortes
          // NO hay ajuste de volÃºmenes, NO hay barge-in, NO hay cortes, NO hay pausas
          // El sistema es completamente fluido - ambos pueden hablar a la vez sin interferencia
          if (data.route === 'audio' && (data.action === 'user_speaking' || data.action === 'user_stopped' || data.action === 'stop_audio')) {
            // Ignorar completamente - no hacer nada
            // El micrÃ³fono permanece abierto, el audio sigue reproduciÃ©ndose
            // stop_audio puede venir de cÃ³digo viejo en Render, pero lo ignoramos completamente
            console.log('[PIPELINE CALL CENTER] âš ï¸ Mensaje', data.action, 'ignorado - sistema fluido sin cortes');
            return;
          }

          if (data.type === 'connection_established' && data.capabilities && typeof data.capabilities.stt === 'boolean') {
            this.sttAvailable = data.capabilities.stt;
            clearSttCapabilitiesTimeout();

            if (!this.sttAvailable) {
              if (!this.sttNoticeShown) {
                this.addMessage('La transcripciÃ³n de voz no estÃ¡ disponible en este momento (STT desactivado en el servidor).', 'system');
                this.sttNoticeShown = true;
              }
              this.stopAudioCapture();
            } else {
              startMicrophoneCapture();
            }
            return;
          }

          // PRIMERO: Manejar mensajes que no tienen route/action (formato diferente del servidor)
          if (!data.route && !data.action && !data.error && data.type !== 'error') {
            console.log('[MCP] Mensaje sin route/action, estructura completa:', JSON.stringify(data, null, 2));
            
            // Intentar detectar si es un mensaje de audio de respuesta
            if (data.audio || data.payload?.audio) {
              const audioBase64 = data.audio || data.payload?.audio;
              console.log('[MCP] âœ… Detectado audio en mensaje alternativo');
              // âœ… SOLO usar isWelcome explÃ­cito del servidor (no fallbacks)
              const isWelcome = data.payload?.isWelcome === true;
              this.clearResponseWatchdog();
              this.awaitingResponse = false;
              this.playAudioResponse(audioBase64, isWelcome);
              return;
            }
            
            // Si tiene type, podrÃ­a ser un mensaje de otro formato
            if (data.type) {
              console.log('[MCP] Mensaje con type:', data.type, 'payload:', data.payload || data);
              // Ignorar mensajes de tipo 'config' que vienen del servidor
              if (data.type === 'config') {
                return;
              }
              return;
            }
          }

          // ðŸš€ FASE 1: Manejar chunks PCM de TTS WebSocket streaming
          if (data.route === 'audio' && data.action === 'tts_chunk' && data.payload && data.payload.audio) {
            console.log('[MCP] âœ… Recibido chunk PCM de TTS WebSocket');
            this.clearResponseWatchdog();
            if (data.payload.isFirst) {
              this.awaitingResponse = false;
              this.isSpeaking = true;
            }
            // Reproducir chunk PCM usando AudioWorklet
            this.handleTTSAudioChunk(data.payload.audio);
            return;
          }

          // ðŸš€ FASE 1: Manejar finalizaciÃ³n de TTS streaming
          if (data.route === 'audio' && data.action === 'tts_complete') {
            console.log('[MCP] âœ… TTS streaming completado');
            // ðŸš€ FULL DUPLEX: No mutear el micrÃ³fono - permitir conversaciÃ³n fluida
            this.isSpeaking = false;
            console.log('[AUDIO-STREAM] âœ… TTS completado - micrÃ³fono permanece abierto para full duplex');
            return;
          }

          // Manejar respuesta de audio TTS (formato estÃ¡ndar - MP3/WAV)
          if (data.route === 'audio' && data.action === 'tts' && data.payload && data.payload.audio) {
            console.log('[MCP] âœ… Recibida respuesta de audio TTS');
            this.clearResponseWatchdog();
            this.awaitingResponse = false;

            // ðŸš€ FASE 1: Si es audio nativo (WAV), intentar usar AudioWorklet
            if (data.payload.isNative && data.payload.format === 'wav' && this.audioWorkletReady) {
              try {
                // Decodificar base64 a ArrayBuffer
                const binaryString = atob(data.payload.audio);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i);
                }

                if (this.playNativeAudio(bytes.buffer)) {
                  console.log('[AUDIO] âœ… Audio nativo reproducido con AudioWorklet');
                  return;
                }
              } catch (error) {
                console.error('[AUDIO] âŒ Error reproduciendo audio nativo, fallback a <audio>:', error);
              }
            }

            // âœ… SOLO usar isWelcome explÃ­cito del servidor (no fallbacks)
            const isWelcome = data.payload.isWelcome === true;
            
            // ðŸš€ WEBRTC PIPELINE: Queue greeting if ringtones are playing
            if (isWelcome && this.waitingForRingtones) {
              console.log('[MCP] ðŸ“ž Greeting received during ringtones - queuing for playback after ringtones');
              this.queuedGreeting = {
                audio: data.payload.audio,
                isWelcome: true
              };
              return;
            }
            
            this.playAudioResponse(data.payload.audio, isWelcome);
            return;
          }

          // ðŸš€ FASE 2: Procesar comandos de UI primero
          if (data.type === 'ui_command' || data.type === 'ui_navigation') {
            console.log('[UI SYSTEM] Comando recibido:', data);
            if (window.UICommandSystem && window.UICommandSystem.handleMessage) {
              window.UICommandSystem.handleMessage(data);
            }
            // Continuar procesando otros mensajes si es necesario
          }

          // ðŸš€ FASE 4: Procesar notificaciones push
          if (data.type === 'push_notification') {
            console.log('[NOTIFICATION] NotificaciÃ³n recibida:', data);
            this.handlePushNotification(data);
          }

	          // Manejar mensajes de error del servidor
	          if (data.route === 'error' && data.action === 'message' && data.payload) {
	            const payloadError = (typeof data.payload.error === 'string') ? data.payload.error : '';
	            const payloadMessage = (typeof data.payload.message === 'string') ? data.payload.message : '';
	            const errorCode = (typeof data.payload.code === 'string') ? data.payload.code : '';

	            const rawErrorText = (payloadError && payloadMessage && payloadMessage !== payloadError)
	              ? `${payloadError}: ${payloadMessage}`
	              : (payloadMessage || payloadError || 'Error desconocido');

	            const isDeepgramNotConfigured =
	              errorCode === 'DEEPGRAM_NOT_CONFIGURED' ||
	              rawErrorText.includes('DEEPGRAM_API_KEY') ||
	              rawErrorText.includes('Deepgram SDK not initialized');

	            const userErrorText = isDeepgramNotConfigured
	              ? 'La transcripciÃ³n de voz no estÃ¡ disponible en este momento (DEEPGRAM_API_KEY no configurada en el servidor).'
	              : rawErrorText;

	            console.error('[MCP] âŒ Error del servidor:', rawErrorText);

	            try {
	              this.addMessage(userErrorText, 'system');
	            } catch (_) { }

	            this.clearResponseWatchdog();
	            this.awaitingResponse = false;

            // Si falta Deepgram, detener streaming para evitar spam de errores
            if (isDeepgramNotConfigured) {
              this.hangupCall('stt_unavailable');
            }
            return;
          }

          // TranscripciÃ³n (interim) - NO mostrar visualmente, solo para uso interno
          if (data.route === 'conserje' && data.action === 'message' && data.payload && data.payload.type === 'transcription_interim' && data.payload.text) {
            // Solo log interno, no mostrar en UI
            console.log('[STT] TranscripciÃ³n interim:', data.payload.text);
            return;
          }

          // TranscripciÃ³n final - NO mostrar visualmente, solo para uso interno
          if (data.route === 'conserje' && data.action === 'message' && data.payload && data.payload.type === 'transcription_final' && data.payload.text) {
            // Solo log interno, no mostrar en UI
            console.log('[STT] TranscripciÃ³n final:', data.payload.text);
            return;
          }

          // Manejar mensaje de respuesta completa del servidor (SOLO texto - fallback si no hay audio)
          // NOTA: El servidor DEBE enviar audio con route: 'audio', action: 'tts' usando Deepgram TTS
          // Si solo recibimos texto, es un error del servidor
          if (data.route === 'conserje' && data.action === 'message' && data.payload && data.payload.type === 'response_complete' && data.payload.text) {
            console.error('[MCP] âŒ ERROR: Respuesta recibida solo como TEXTO - el servidor debe enviar audio TTS con Deepgram');
            console.error('[MCP] âŒ El servidor debe usar Deepgram TTS y enviar route: "audio", action: "tts"');
            this.clearResponseWatchdog();
            this.awaitingResponse = false;
            
            const responseText = data.payload.text;

            // NO mostrar mensaje en el chat cuando hay llamada activa
            if (!this.activeCall) {
            this.addMessage(responseText, 'system');
            }

            const liveTranscript = document.getElementById('sandra-live-transcript');
            if (liveTranscript) {
              liveTranscript.classList.add('hidden');
              liveTranscript.textContent = '';
            }
            
            // NO usar SpeechSynthesis - el servidor debe enviar audio
            console.error('[MCP] âŒ No se puede reproducir respuesta: el servidor debe enviar audio TTS');
            this.isSpeaking = false;
            return;
          }

          // Manejar mensaje de noSpeech (sin transcripciÃ³n)
          if (data.route === 'conserje' && data.action === 'message' && data.payload && data.payload.type === 'noSpeech' && data.payload.message) {
            console.log('[MCP] âš ï¸ No se detectÃ³ habla');
            this.clearResponseWatchdog();
            this.awaitingResponse = false;
            return;
          }

          // Manejar errores del servidor (pero solo si realmente son errores crÃ­ticos)
          if (data.error || (data.type === 'error')) {
            const errorMsg = data.error || data.message || '';
            console.error('[MCP] âŒ Error del servidor:', errorMsg, 'Mensaje completo:', JSON.stringify(data, null, 2));
            this.clearResponseWatchdog();
            this.awaitingResponse = false;

            // Si es error de transcripciÃ³n, enviar mensaje de error al usuario
            if (data.payload && data.payload.type === 'transcription_error') {
              console.warn('[MCP] âš ï¸ Error de transcripciÃ³n, reintentando...');
              // No hacer nada, el watchdog reintentarÃ¡
            }
            return;
          }


          // Manejar respuestas de STT con error
          if (data.route === 'audio' && data.action === 'stt' && data.payload && data.payload.error) {
            console.error('[MCP] âŒ Error en STT:', data.payload.error);
            this.clearResponseWatchdog();
            this.awaitingResponse = false;
            return;
          }

          // Log para mensajes no manejados (con mÃ¡s detalle) - solo si no es un error ya manejado
          if (data.route !== 'system' && data.action !== 'connected' && data.route !== 'error') {
            console.log('[MCP] âš ï¸ Mensaje no manejado:', JSON.stringify(data, null, 2));
            // Intentar manejar mensajes de texto del servidor
            if (data.route === 'conserje' && data.action === 'message' && data.payload && data.payload.message) {
              console.log('[MCP] Mensaje del servidor:', data.payload.message);
            }
          }
        };

        ws.onerror = (error) => {
          console.error('[MCP] âŒ Error en WebSocket:', error);
          alert('Error de conexiÃ³n. Por favor, verifica que el servidor estÃ© funcionando.');
        };

        // ðŸš€ PIPELINE ROBUSTO: Buffer de reenvÃ­o para manejar cortes de red
        this.audioBuffer = []; // Almacenar Ãºltimos 3-4s de audio (12-16 chunks de 250ms)
        this.maxBufferSize = 16; // ðŸš€ GPT-4o: Aumentado a 4 segundos (16 chunks) para reconexiones mÃ¡s lentas
        // ðŸš€ GPT-4o: sessionId debe mantenerse entre reconexiones - NO regenerar
        if (!this.sessionId) {
          this.sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(7)}`;
          console.log(`[PIPELINE ROBUSTO] ðŸ†” Nueva sesiÃ³n creada: ${this.sessionId}`);
        } else {
          console.log(`[PIPELINE ROBUSTO] ðŸ”„ Manteniendo sessionId existente: ${this.sessionId}`);
        }
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 3;
        this.reconnectDelay = 1000; // 1 segundo inicial
        // ðŸš€ GPT-4o: Timer para enviar silencio cuando el usuario deja de hablar
        this.silenceKeepAliveTimer = null;
        this.lastAudioSentAt = Date.now();

        ws.onclose = (event) => {
          console.log('[MCP] WebSocket cerrado', { code: event.code, reason: event.reason, wasClean: event.wasClean });
          
          // ðŸš€ PIPELINE ROBUSTO: Intentar reconexiÃ³n automÃ¡tica
          if (this.reconnectAttempts < this.maxReconnectAttempts && this.activeCall === ws) {
            this.reconnectAttempts++;
            console.log(`[MCP] ðŸ”„ Intentando reconexiÃ³n ${this.reconnectAttempts}/${this.maxReconnectAttempts}...`);
            
            setTimeout(async () => {
              try {
                // ðŸš€ PROTECCIÃ“N: Verificar que no hay una conexiÃ³n activa antes de reconectar
                if (this.activeCall && (this.activeCall.readyState === WebSocket.CONNECTING || this.activeCall.readyState === WebSocket.OPEN)) {
                  console.log('[MCP] âš ï¸ Ya hay una conexiÃ³n activa, cancelando reconexiÃ³n');
                  this.reconnectAttempts = 0;
                  return;
                }
                
                // ðŸš€ RECONEXIÃ“N: Reutilizar startRealTimeCall() con protecciÃ³n
                // Esto asegura que los handlers se configuren correctamente
                console.log('[MCP] ðŸ”„ Iniciando reconexiÃ³n mediante startRealTimeCall()...');
                await this.startRealTimeCall();
                
                // Esperar a que el WebSocket se conecte antes de reenviar buffer
                const maxWait = 5000; // 5 segundos mÃ¡ximo
                const startWait = Date.now();
                while (this.activeCall && this.activeCall.readyState !== WebSocket.OPEN && (Date.now() - startWait) < maxWait) {
                  await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Reenviar buffer de audio almacenado si la conexiÃ³n estÃ¡ abierta
                if (this.activeCall && this.activeCall.readyState === WebSocket.OPEN && this.audioBuffer.length > 0) {
                  console.log(`[MCP] ðŸ“¦ Reenviando ${this.audioBuffer.length} chunks de audio almacenados...`);
                  for (const audioChunk of this.audioBuffer) {
                    this.activeCall.send(JSON.stringify(audioChunk));
                  }
                }
                
                this.reconnectAttempts = 0; // Reset en caso de Ã©xito
              } catch (error) {
                console.error('[MCP] âŒ Error en reconexiÃ³n:', error);
              }
            }, this.reconnectDelay * this.reconnectAttempts);
            
            return; // No limpiar recursos aÃºn, esperar reconexiÃ³n
          }
          
          // Solo limpiar si no hay mÃ¡s intentos de reconexiÃ³n
          clearSttCapabilitiesTimeout();
          this.sttAvailable = null;
          this.sttNoticeShown = false;
          microphoneStartPromise = null;
          microphoneStarted = false;
          this.stopAudioCapture();
          this.activeCall = null;
          this.setHeroCallActive(false);
          this.chatLocked = false;
          this.audioBuffer = []; // Limpiar buffer
          this.reconnectAttempts = 0;

          // Rehabilitar input del chat cuando termina la llamada
          const input = document.getElementById('sandra-input');
          const sendBtn = document.getElementById('sandra-send-btn');
          if (input) {
            input.disabled = false;
            input.placeholder = 'Escribe tu mensaje...';
          }
          if (sendBtn) {
            sendBtn.disabled = false;
          }

          const liveTranscript = document.getElementById('sandra-live-transcript');
          if (liveTranscript) {
            liveTranscript.classList.add('hidden');
            liveTranscript.textContent = '';
          }
        };
      }

      addMessage(text, type) {
        // NO agregar mensajes al chat durante llamada de voz activa
        // EXCEPCIÃ“N: Los mensajes del usuario ('user') siempre se muestran para feedback visual
        // Las respuestas del sistema durante llamada de voz NO se muestran (van solo a voz)
        if (this.activeCall && type !== 'user') {
          console.log('[CHAT] âš ï¸ Mensaje bloqueado durante llamada: Tipo:', type, 'Texto:', text.substring(0, 50));
          return;
        }

        // Asegurar que el prompt de llamada estÃ© visible cuando se envÃ­a mensaje (si no hay llamada activa)
        if (!this.activeCall && !this.chatLocked) {
          const callPrompt = document.getElementById('sandra-call-prompt');
          if (callPrompt) {
            callPrompt.style.display = 'flex';
            callPrompt.style.visibility = 'visible';
          }
        }

        const container = document.getElementById('sandra-messages');
        if (!container) {
          console.error('[CHAT] âŒ Contenedor de mensajes no encontrado');
          return;
        }

        const isUser = type === 'user';
        const html = `
          <div class="flex gap-2 ${isUser ? 'flex-row-reverse' : ''}">
            ${!isUser ? '<div class="w-6 h-6 rounded-full bg-gradient-to-tr from-blue-400 to-purple-500 flex-shrink-0 flex items-center justify-center text-[10px] text-white font-bold">S</div>' : ''}
            <div class="${isUser ? 'bg-blue-600 text-white' : 'bg-white border border-slate-100 text-slate-700'} p-2.5 rounded-xl ${isUser ? 'rounded-tr-none' : 'rounded-tl-none'} shadow-sm text-xs max-w-[85%]"><p>${text}</p></div>
          </div>`;
        container.insertAdjacentHTML('beforeend', html);
        container.scrollTop = container.scrollHeight;
      }

      showTyping(show) {
        const el = document.getElementById('sandra-typing');
        if (show) el.classList.remove('hidden'); else el.classList.add('hidden');
      }

      // BINARY STREAMING PLAYER
      handleAudioChunk(arrayBuffer) {
        if (!this.audioCtx) this.ensureAudioContext();
        if (this.audioCtx.state === 'suspended') this.audioCtx.resume();

        console.log(`[AUDIO-STREAM] Recibido chunk: ${arrayBuffer.byteLength} bytes`);

        // Decodificar y reproducir
        this.audioCtx.decodeAudioData(arrayBuffer, (buffer) => {
          const source = this.audioCtx.createBufferSource();
          source.buffer = buffer;
          source.connect(this.audioCtx.destination);
          source.start(0);
        }, (e) => console.error("Error decodificando audio stream:", e));
      }

      // ðŸš€ FASE 1: Setup AudioWorklet para reproducciÃ³n PCM
      async setupAudioWorklet() {
        try {
          // Create AudioContext with 24kHz sample rate (match Deepgram TTS)
          this.audioWorkletContext = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: 24000
          });

          // Load AudioWorklet processor
          await this.audioWorkletContext.audioWorklet.addModule('assets/js/audio-worklet-processor.js');

          // Create AudioWorkletNode
          this.audioWorkletNode = new AudioWorkletNode(this.audioWorkletContext, 'pcm-playback-processor');
          this.audioWorkletNode.connect(this.audioWorkletContext.destination);

          this.audioWorkletReady = true;
          console.log('[AUDIO] âœ… AudioWorklet initialized successfully');
        } catch (error) {
          console.error('[AUDIO] âŒ Error setting up AudioWorklet:', error);
          this.audioWorkletReady = false;
          // Fallback to <audio> element if AudioWorklet fails
        }
      }

      // ðŸš€ FASE 1: Handle TTS WebSocket PCM chunks
      handleTTSAudioChunk(pcmChunkBase64) {
        if (!this.audioWorkletReady || !this.audioWorkletNode) {
          console.warn('[AUDIO] âš ï¸ AudioWorklet not ready, cannot play PCM chunk');
          return;
        }

        try {
          // Validate base64 string
          if (!pcmChunkBase64 || typeof pcmChunkBase64 !== 'string') {
            console.warn('[AUDIO] âš ï¸ Invalid PCM chunk (not a string), skipping');
            return;
          }

          // Decode base64 to ArrayBuffer
          const binaryString = atob(pcmChunkBase64);
          if (binaryString.length === 0) {
            console.warn('[AUDIO] âš ï¸ Empty PCM chunk, skipping');
            return;
          }

          // Validate length is multiple of 2 (Int16 requires 2 bytes per sample)
          if (binaryString.length % 2 !== 0) {
            console.warn('[AUDIO] âš ï¸ Invalid PCM chunk length (not multiple of 2), skipping');
            return;
          }

          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }

          // Convert Int16 PCM to Float32Array (-1.0 to 1.0)
          const int16Array = new Int16Array(bytes.buffer);
          const float32Array = new Float32Array(int16Array.length);
          for (let i = 0; i < int16Array.length; i++) {
            float32Array[i] = int16Array[i] / 32768.0;
          }

          // Send to AudioWorklet
          this.audioWorkletNode.port.postMessage({
            type: 'audio',
            data: float32Array.buffer
          });

          this.isSpeaking = true;
        } catch (error) {
          console.error('[AUDIO] âŒ Error handling TTS PCM chunk:', error);
          // Don't break the flow, just log the error
        }
      }

      // ðŸš€ FASE 1: Play native audio file (WAV) using AudioWorklet
      async playNativeAudio(audioBuffer) {
        if (!this.audioWorkletReady || !this.audioWorkletNode) {
          console.warn('[AUDIO] âš ï¸ AudioWorklet not ready, falling back to <audio>');
          return false;
        }

        try {
          // Send native audio to AudioWorklet
          this.audioWorkletNode.port.postMessage({
            type: 'native',
            data: audioBuffer
          });

          this.isSpeaking = true;
          console.log('[AUDIO] âœ… Native audio sent to AudioWorklet');
          return true;
        } catch (error) {
          console.error('[AUDIO] âŒ Error playing native audio:', error);
          return false;
        }
      }

      // ðŸš€ PIPELINE CALL CENTER: clearAudio DESACTIVADO
      // NO se pausa audio, NO se limpia, NO hay cortes
      // El audio sigue reproduciÃ©ndose naturalmente
      clearAudio() {
        // DESACTIVADO - NO hacer nada para evitar cortes
        // El audio seguirÃ¡ reproduciÃ©ndose naturalmente
        console.log('[AUDIO] âš ï¸ clearAudio() llamado pero DESACTIVADO - pipeline call center (sin cortes)');
      }

      // ðŸš€ PIPELINE ROBUSTO: Barge-in suave con reducciÃ³n de volumen (no cortes)
      setupBargeInDetection(audioContext, stream) {
        if (!stream || !audioContext) {
          console.warn('[BARGE-IN] No se puede configurar: stream o audioContext no disponible');
          return;
        }

        try {
          // Crear AnalyserNode para detectar nivel de audio del micrÃ³fono
          this.bargeInAnalyser = audioContext.createAnalyser();
          this.bargeInAnalyser.fftSize = 2048;
          this.bargeInAnalyser.smoothingTimeConstant = 0.8; // Suavizado para evitar fluctuaciones

          const source = audioContext.createMediaStreamSource(stream);
          source.connect(this.bargeInAnalyser);

          const dataArray = new Uint8Array(this.bargeInAnalyser.frequencyBinCount);
          const SPEAKING_THRESHOLD = -40; // dB - umbral para detectar que el usuario habla
          const VOLUME_REDUCTION = 0.3; // Reducir volumen de IA a 30% cuando usuario habla

          // ðŸš€ PIPELINE ROBUSTO: Barge-in suave - reducir volumen sin cortar
          console.log('[BARGE-IN] âœ… Sistema de barge-in suave activado (reducciÃ³n de volumen, sin cortes)');
          
          // Limpiar cualquier intervalo anterior si existe
          if (this.bargeInCheckInterval) {
            clearInterval(this.bargeInCheckInterval);
            this.bargeInCheckInterval = null;
          }
          
          // Configurar intervalo para detectar voz del usuario
          this.bargeInCheckInterval = setInterval(() => {
            try {
              if (!this.bargeInAnalyser || !this.currentAudio) return;
              
              this.bargeInAnalyser.getByteFrequencyData(dataArray);
              
              // Calcular RMS (Root Mean Square) para medir potencia de audio
              let sum = 0;
              for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i] * dataArray[i];
              }
              const rms = Math.sqrt(sum / dataArray.length);
              const db = 20 * Math.log10(rms + 1); // Convertir a dB
              
              // Si el usuario habla (RMS > umbral), reducir volumen de IA gradualmente
              if (db > SPEAKING_THRESHOLD) {
                if (!this.isUserSpeaking) {
                  this.isUserSpeaking = true;
                  // Guardar volumen original si no estÃ¡ guardado
                  if (this.audioVolumeBeforeBargeIn === undefined) {
                    this.audioVolumeBeforeBargeIn = this.currentAudio.volume || 1.0;
                  }
                  // Reducir volumen gradualmente
                  this.currentAudio.volume = VOLUME_REDUCTION;
                  console.log('[BARGE-IN] ðŸŽ¤ Usuario hablando - reduciendo volumen de IA a', VOLUME_REDUCTION);
                }
              } else {
                // Si el usuario calla, restaurar volumen gradualmente
                if (this.isUserSpeaking) {
                  this.isUserSpeaking = false;
                  if (this.audioVolumeBeforeBargeIn !== undefined) {
                    this.currentAudio.volume = this.audioVolumeBeforeBargeIn;
                    console.log('[BARGE-IN] ðŸ”‡ Usuario callÃ³ - restaurando volumen de IA a', this.audioVolumeBeforeBargeIn);
                  }
                }
              }
            } catch (error) {
              console.error('[BARGE-IN] Error en detecciÃ³n:', error);
            }
          }, 100); // Verificar cada 100ms para respuesta rÃ¡pida
          
        } catch (error) {
          console.error('[BARGE-IN] Error configurando barge-in:', error);
        }
      }

      cleanupBargeIn() {
        if (this.bargeInCheckInterval) {
          clearInterval(this.bargeInCheckInterval);
          this.bargeInCheckInterval = null;
        }
        if (this.bargeInAnalyser) {
          try {
            this.bargeInAnalyser.disconnect();
          } catch (_) { }
          this.bargeInAnalyser = null;
        }
        this.isUserSpeaking = false;
        // Restaurar volumen si estaba bajado
        if (this.currentAudio && this.isUserSpeaking) {
          this.currentAudio.volume = this.audioVolumeBeforeBargeIn;
        }
      }

      // AUDIO FIX: Improved playAudioResponse with 3s delay on revoke
      playAudioResponse(audioBase64, isWelcome = false) {
        console.log('[AUDIO] playAudioResponse called with isWelcome:', isWelcome, 'audioBase64 type:', typeof audioBase64, 'length:', audioBase64?.length);

        // ðŸš€ FASE 1: Detect and reject WebSocket objects (should never be sent to client)
        if (audioBase64 && typeof audioBase64 === 'object' && audioBase64.type === 'streaming') {
          console.error('[AUDIO] âŒ ERROR: Received WebSocket object instead of audio data. This should not happen - server bug.');
          console.error('[AUDIO] Object received:', audioBase64);
          this.isSpeaking = false;
          return;
        }

        if (!audioBase64 || typeof audioBase64 !== 'string') {
          console.error('[AUDIO] âŒ Audio base64 invÃ¡lido:', typeof audioBase64, audioBase64);
          this.isSpeaking = false;
          return;
        }

        if (audioBase64.length < 100) {
          console.error('[AUDIO] âŒ Audio base64 muy pequeÃ±o:', audioBase64.length, 'bytes');
          this.isSpeaking = false;
          return;
        }

        // ðŸš€ PIPELINE CALL CENTER: NO pausar audio anterior - permitir que termine naturalmente
        // El audio anterior seguirÃ¡ reproduciÃ©ndose mientras el nuevo se reproduce
        // Esto permite conversaciÃ³n fluida sin cortes, como en call centers reales
        if (this.currentAudio && !this.currentAudio.paused) {
          console.log('[AUDIO] ðŸ”Š Nuevo audio recibido - audio anterior seguirÃ¡ reproduciÃ©ndose (sin pausar)');
          // NO pausar - dejar que ambos audios se reproduzcan (el anterior terminarÃ¡ naturalmente)
          // Solo limpiar referencia despuÃ©s de que termine naturalmente
        }

        this.isSpeaking = true;

        let blobUrl;
        try {
          const byteCharacters = atob(audioBase64);
          console.log('[AUDIO] atob decodificado:', byteCharacters.length, 'caracteres');

          const byteNumbers = new Array(byteCharacters.length);
          for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
          }
          const byteArray = new Uint8Array(byteNumbers);
          console.log('[AUDIO] Uint8Array creado:', byteArray.length, 'bytes');

          // Usar audio/mpeg en lugar de audio/mp3 para mejor compatibilidad
          const blob = new Blob([byteArray], { type: 'audio/mpeg' });
          blobUrl = URL.createObjectURL(blob);

          console.log('[AUDIO] âœ… Blob creado:', { size: blob.size, type: blob.type, blobUrl: blobUrl.substring(0, 50) });
        } catch (error) {
          console.error('[AUDIO] âŒ Error decodificando base64:', error);
          this.isSpeaking = false;
          return;
        }

        const audio = new Audio(blobUrl);
        audio._blobUrl = blobUrl;
        
        // ðŸš€ FULL DUPLEX: Ajustar volumen segÃºn si el usuario estÃ¡ hablando
        // Si el usuario estÃ¡ hablando, bajar volumen de la IA para darle atenciÃ³n
        if (this.isUserSpeaking) {
          audio.volume = 0.3; // 30% - atenciÃ³n al usuario
          this.audioVolumeBeforeBargeIn = 1.0; // Guardar volumen normal para restaurar despuÃ©s
          console.log('[FULL DUPLEX] ðŸŽ¤ IA empieza a hablar pero usuario estÃ¡ hablando - volumen inicial: 0.3');
        } else {
          audio.volume = 1.0; // Volumen mÃ¡ximo si el usuario no estÃ¡ hablando
        }

        // ðŸŽ¯ CONTROL DE VELOCIDAD: MÃ¡s rÃ¡pido (15%) para mayor naturalidad
        if (isWelcome) {
          audio.playbackRate = 1.0; // Saludo nativo ya tiene velocidad correcta
        } else {
          audio.playbackRate = 1.15; // Acelerar TTS generado
        }

        this.currentAudio = audio;

        console.log('[AUDIO] âš™ï¸ ConfiguraciÃ³n de audio:', {
          volume: audio.volume,
          playbackRate: audio.playbackRate,
          isWelcome: isWelcome,
          duration: 'unknown (se cargarÃ¡ despuÃ©s)'
        });

        console.log('[AUDIO] Audio element creado, intentando reproducir...');

        // Para el saludo inicial, esperar a que el buffer estÃ© completamente cargado
        if (isWelcome) {
          console.log('[AUDIO] â³ Esperando buffer completo del saludo (carga completa para evitar cortes)...');

          // Wait for the audio to be fully loaded before playing
          const waitForFullLoad = () => {
            if (audio.readyState >= 4) { // HAVE_ENOUGH_DATA - completely loaded
              console.log('[AUDIO] âœ… Saludo completamente cargado (readyState: 4), reproduciendo...');
              audio.play().then(() => {
                console.log('[AUDIO] âœ… Saludo reproduciÃ©ndose a velocidad:', audio.playbackRate);
              }).catch(e => {
                console.error("[AUDIO] âŒ Error en play():", e.name, e.message);
                this.isSpeaking = false;
              });
            } else {
              console.log('[AUDIO] â³ Cargando saludo (readyState:', audio.readyState, '), esperando...');
              setTimeout(waitForFullLoad, 100);
            }
          };

          // Wait for canplaythrough (indicates audio can play through to the end)
          audio.addEventListener('canplaythrough', () => {
            console.log('[AUDIO] âœ… Evento canplaythrough disparado - audio listo para reproducirse completo');
            if (audio.paused) {
            audio.play().then(() => {
                console.log('[AUDIO] âœ… Saludo reproduciÃ©ndose despuÃ©s de canplaythrough');
            }).catch(e => {
                console.error("[AUDIO] âŒ Error en play() despuÃ©s de canplaythrough:", e.name, e.message);
              this.isSpeaking = false;
            });
            }
          }, { once: true });

          audio.addEventListener('loadeddata', () => {
            console.log('[AUDIO] âœ… Evento loadeddata disparado');
          });

          audio.addEventListener('loadedmetadata', () => {
            console.log('[AUDIO] âœ… Metadata cargada - DuraciÃ³n:', audio.duration, 'segundos');
          });

          waitForFullLoad();
        } else {
          console.log('[AUDIO] â–¶ï¸  Reproduciendo audio normal...');
          audio.play().then(() => {
            console.log('[AUDIO] âœ… Audio reproduciÃ©ndose');
          }).catch(e => {
            console.error("[AUDIO] âŒ Error en play():", e.name, e.message);
            this.isSpeaking = false;
          });
        }

        audio.addEventListener('error', (e) => {
          console.error('[AUDIO] âŒ Error evento de audio:', audio.error?.message || audio.error?.code);
          this.isSpeaking = false;
        });

        audio.onended = () => {
          console.log('[AUDIO] âœ… Audio finalizado completamente');

          // ðŸš€ PIPELINE CALL CENTER: Audio finalizado - micrÃ³fono SIEMPRE abierto
          // NO hay barge-in, NO hay cortes, NO hay pausas
          // El micrÃ³fono permanece abierto para conversaciÃ³n fluida continua
          this.isSpeaking = false;
          console.log('[AUDIO] âœ… Audio finalizado - micrÃ³fono permanece abierto (pipeline call center)');

          // CRITICAL FIX: Wait 5 seconds before revoking to ensure audio fully finishes
          // This prevents cutting off the end of the audio and gives time for the buffer to clear
          setTimeout(() => {
            if (audio._blobUrl) {
              URL.revokeObjectURL(audio._blobUrl);
              audio._blobUrl = null;
            }
            if (this.currentAudio === audio) {
            this.currentAudio = null;
            }
          }, 5000); // Increased from 3000ms to 5000ms to prevent cuts
        };

        console.log('[AUDIO] â–¶ï¸  Llamando play() inicial...');
        audio.play().then(() => {
          console.log('[AUDIO] âœ… play() promise resuelto');
        }).catch(e => {
          console.error("[AUDIO] âŒ play() promise rechazado:", e.name, e.message);
          this.isSpeaking = false;
        });
      }

      // NOTA: Esta funciÃ³n fue eliminada - NO usar SpeechSynthesis del navegador
      // El servidor debe enviar audio TTS usando Deepgram con route: 'audio', action: 'tts'
      // El cliente usa playAudioResponse() para reproducir el audio recibido del servidor
    }

    // ðŸš€ FASE 4: Manejar notificaciones push
    handlePushNotification(data) {
      try {
        const { title, message, notificationType, timestamp } = data;
        
        // Crear elemento de notificaciÃ³n si no existe
        let notificationContainer = document.getElementById('sandra-notification-container');
        if (!notificationContainer) {
          notificationContainer = document.createElement('div');
          notificationContainer.id = 'sandra-notification-container';
          notificationContainer.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            max-width: 400px;
            pointer-events: none;
          `;
          document.body.appendChild(notificationContainer);
        }

        // Crear notificaciÃ³n
        const notification = document.createElement('div');
        notification.className = 'sandra-notification';
        notification.style.cssText = `
          background: linear-gradient(135deg, rgba(37, 99, 235, 0.95), rgba(59, 130, 246, 0.95));
          color: white;
          padding: 16px 20px;
          border-radius: 12px;
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
          margin-bottom: 12px;
          animation: slideInRight 0.3s ease-out;
          pointer-events: auto;
          backdrop-filter: blur(10px);
          border: 1px solid rgba(255, 255, 255, 0.2);
        `;

        // Icono segÃºn tipo
        const icons = {
          booking: 'ðŸ“…',
          update: 'ðŸ”„',
          alert: 'âš ï¸',
          message: 'ðŸ’¬',
          payment: 'ðŸ’³'
        };
        const icon = icons[notificationType] || 'ðŸ””';

        notification.innerHTML = `
          <div style="display: flex; align-items: flex-start; gap: 12px;">
            <span style="font-size: 24px; line-height: 1;">${icon}</span>
            <div style="flex: 1;">
              <div style="font-weight: 600; font-size: 16px; margin-bottom: 4px;">${title}</div>
              <div style="font-size: 14px; opacity: 0.9; line-height: 1.4;">${message}</div>
            </div>
            <button class="notification-close" style="
              background: rgba(255, 255, 255, 0.2);
              border: none;
              color: white;
              width: 24px;
              height: 24px;
              border-radius: 50%;
              cursor: pointer;
              font-size: 16px;
              line-height: 1;
              padding: 0;
              display: flex;
              align-items: center;
              justify-content: center;
            ">Ã—</button>
          </div>
        `;

        // AÃ±adir animaciÃ³n CSS si no existe
        if (!document.getElementById('notification-styles')) {
          const style = document.createElement('style');
          style.id = 'notification-styles';
          style.textContent = `
            @keyframes slideInRight {
              from {
                transform: translateX(100%);
                opacity: 0;
              }
              to {
                transform: translateX(0);
                opacity: 1;
              }
            }
            @keyframes slideOutRight {
              from {
                transform: translateX(0);
                opacity: 1;
              }
              to {
                transform: translateX(100%);
                opacity: 0;
              }
            }
            .notification-close:hover {
              background: rgba(255, 255, 255, 0.3) !important;
            }
          `;
          document.head.appendChild(style);
        }

        // BotÃ³n de cerrar
        const closeBtn = notification.querySelector('.notification-close');
        closeBtn.addEventListener('click', () => {
          notification.style.animation = 'slideOutRight 0.3s ease-out';
          setTimeout(() => notification.remove(), 300);
        });

        // Auto-cerrar despuÃ©s de 5 segundos
        setTimeout(() => {
          if (notification.parentNode) {
            notification.style.animation = 'slideOutRight 0.3s ease-out';
            setTimeout(() => notification.remove(), 300);
          }
        }, 5000);

        notificationContainer.appendChild(notification);
        console.log(`[NOTIFICATION] âœ… NotificaciÃ³n mostrada: ${title}`);
      } catch (error) {
        console.error('[NOTIFICATION] Error mostrando notificaciÃ³n:', error);
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      new SandraWidget();
      
      // ðŸš€ FASE 2: Inicializar sistema de comandos UI
      window.UICommandSystem = {
        handlers: {
          'scroll-to': function(target) {
            try {
              const element = document.getElementById(target) || 
                             document.querySelector(`.${target}`) ||
                             document.querySelector(`[data-section="${target}"]`);
              if (!element) {
                console.warn(`[UI] âš ï¸ Elemento no encontrado: ${target}`);
                return false;
              }
              element.scrollIntoView({ behavior: 'smooth', block: 'start' });
              console.log(`[UI] ðŸ“œ Scroll a: ${target}`);
              return true;
            } catch (error) {
              console.error('[UI] Error scrolling:', error);
              return false;
            }
          },
          'click': function(target) {
            try {
              const element = document.getElementById(target) || 
                             document.querySelector(`.${target}`);
              if (!element) {
                console.warn(`[UI] âš ï¸ Elemento no encontrado: ${target}`);
                return false;
              }
              element.click();
              const originalBg = element.style.background;
              element.style.background = 'rgba(255, 200, 0, 0.3)';
              setTimeout(() => { element.style.background = originalBg; }, 300);
              console.log(`[UI] ðŸ–±ï¸ Click en: ${target}`);
              return true;
            } catch (error) {
              console.error('[UI] Error clicking:', error);
              return false;
            }
          },
          'toggle-modal': function(target, value) {
            try {
              const modal = document.getElementById(target) || 
                           document.querySelector(`.${target}`);
              if (!modal) {
                console.warn(`[UI] âš ï¸ Modal no encontrado: ${target}`);
                return false;
              }
              if (value === 'open') {
                modal.style.display = 'flex';
                modal.classList.add('modal-open');
              } else if (value === 'close') {
                modal.style.display = 'none';
                modal.classList.remove('modal-open');
              }
              console.log(`[UI] ðŸªŸ Modal ${value}: ${target}`);
              return true;
            } catch (error) {
              console.error('[UI] Error toggle modal:', error);
              return false;
            }
          },
          'highlight': function(target) {
            try {
              const element = document.getElementById(target) || 
                             document.querySelector(`.${target}`);
              if (!element) {
                console.warn(`[UI] âš ï¸ Elemento no encontrado: ${target}`);
                return false;
              }
              document.querySelectorAll('.highlighted').forEach(el => {
                el.classList.remove('highlighted');
              });
              element.classList.add('highlighted');
              element.scrollIntoView({ behavior: 'smooth', block: 'center' });
              setTimeout(() => { element.classList.remove('highlighted'); }, 3000);
              console.log(`[UI] âœ¨ Highlight en: ${target}`);
              return true;
            } catch (error) {
              console.error('[UI] Error highlighting:', error);
              return false;
            }
          }
        },
        navigate: function(section, sectionId) {
          try {
            const element = document.getElementById(sectionId);
            if (!element) {
              console.warn(`[NAV] âš ï¸ SecciÃ³n no encontrada: ${sectionId}`);
              return false;
            }
            element.scrollIntoView({ behavior: 'smooth', block: 'start' });
            element.classList.add('nav-highlight');
            setTimeout(() => { element.classList.remove('nav-highlight'); }, 500);
            console.log(`[NAV] ðŸ§­ NavegaciÃ³n a: ${section}`);
            return true;
        } catch (error) {
            console.error('[NAV] Error navigating:', error);
            return false;
          }
        },
        handleMessage: function(message) {
          if (message.type === 'ui_command') {
            const { command, target, value } = message;
            const handler = this.handlers[command];
            if (handler) {
              return handler(target, value);
            }
          } else if (message.type === 'ui_navigation') {
            const { section, sectionId } = message;
            return this.navigate(section, sectionId);
          }
          return false;
        }
      };
      console.log('[UI SYSTEM] âœ… Sistema de comandos UI inicializado');
    });
  </script>
  <script src="/assets/js/websocket-stream-client.js" defer></script>
</body>

</html>